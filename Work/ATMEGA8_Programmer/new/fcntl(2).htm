<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0066)http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html -->
<HTML><HEAD><TITLE>fcntl(2)</TITLE>
<META http-equiv=Content-Type content="text/html; charset=utf-8">
<STYLE type=text/css>BODY {
	COLOR: #000000; BACKGROUND-COLOR: #f8f8f8
}
B {
	COLOR: #502000
}
I {
	COLOR: #006000
}
H2 {
	FONT-SIZE: 100%; COLOR: #a00000; PADDING-TOP: 15px
}
H3 {
	PADDING-LEFT: 20px; FONT-SIZE: 100%; COLOR: #600000; PADDING-TOP: 10px
}
PRE {
	FONT-FAMILY: monospace, courier
}
A:link {
	COLOR: blue; TEXT-DECORATION: none
}
A:visited {
	COLOR: blue; TEXT-DECORATION: none
}
A:hover {
	COLOR: red; TEXT-DECORATION: underline
}
A:active {
	BACKGROUND-COLOR: #ffd0d0; TEXT-DECORATION: underline
}
</STYLE>

<META content="MSHTML 6.00.2900.3314" name=GENERATOR></HEAD>
<BODY><A name=section_dir></A>
<FORM action=http://www.google.com/custom method=get>
<TABLE cellSpacing=0 cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD align=left><FONT size=-1><A 
      href="http://www.kernel.org/doc/man-pages/index.html">home</A> &nbsp; <A 
      href="http://www.kernel.org/doc/man-pages/contributing.html">contributing</A> 
      &nbsp; <A 
      href="http://www.kernel.org/doc/man-pages/reporting_bugs.html">bugs</A> 
      &nbsp; <A 
      href="http://www.kernel.org/doc/man-pages/download.html">download</A> 
      &nbsp; <A 
      href="http://www.kernel.org/doc/man-pages/online_pages.html">online 
      pages</A> &nbsp; </FONT></TD>
    <TD align=right><INPUT maxLength=255 size=10 name=q> <INPUT type=hidden 
      value=kernel.org/doc/man-pages/online/pages name=sitesearch> <INPUT type=submit value="Search online pages" name=sa> 
</TD></TR></TBODY></TABLE></FORM>
<HR>

<P><FONT size=-2><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#NAME">NAME</A> 
| <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#SYNOPSIS">SYNOPSIS</A> 
| <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#DESCRIPTION">DESCRIPTION</A> 
| <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#RETURN_VALUE">RETURN 
VALUE</A> | <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#ERRORS">ERRORS</A> 
| <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#CONFORMING_TO">CONFORMING 
TO</A> | <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#NOTES">NOTES</A> 
| <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#BUGS">BUGS</A> 
| <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#SEE_ALSO">SEE 
ALSO</A> | <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#COLOPHON">COLOPHON</A></FONT> 
<PRE><!-- Manpage converted by man2html 3.0.1 -->
FCNTL(2)                      Linux Programmer's Manual                      FCNTL(2)
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#NAME" 
name=NAME></A>
<H2>NAME &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       fcntl - manipulate file descriptor
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#SYNOPSIS" 
name=SYNOPSIS></A>
<H2>SYNOPSIS &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       <B>#include</B> <B>&lt;unistd.h&gt;</B>
       <B>#include</B> <B>&lt;fcntl.h&gt;</B>

       <B>int</B> <B>fcntl(int</B> <I>fd</I><B>,</B> <B>int</B> <I>cmd</I><B>,</B> <B>...</B> <B>/*</B> <I>arg</I> <B>*/</B> <B>);</B>
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#DESCRIPTION" 
name=DESCRIPTION></A>
<H2>DESCRIPTION &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       <B>fcntl</B>() performs one of the operations described below on the open file
       descriptor <I>fd</I>.  The operation is determined by <I>cmd</I>.

       <B>fcntl</B>() can take an optional third argument.  Whether or not this argument is
       required is determined by <I>cmd</I>.  The required argument type is indicated in
       parentheses after each <I>cmd</I> name (in most cases, the required type is <I>long</I>, and
       we identify the argument using the name <I>arg</I>), or <I>void</I> is specified if the
       argument is not required.
</PRE>
<H3>Duplicating a file descriptor</H3><PRE>       <B>F_DUPFD</B> (<I>long</I>)
              Find the lowest numbered available file descriptor greater than or
              equal to <I>arg</I> and make it be a copy of <I>fd</I>.  This is different from
              <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup2.2.html">dup2(2)</A>, which uses exactly the descriptor specified.

              On success, the new descriptor is returned.

              See <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup.2.html">dup(2)</A> for further details.

       <B>F_DUPFD_CLOEXEC</B> (<I>long</I>; since Linux 2.6.24)
              As for <B>F_DUPFD</B>, but additionally set the close-on-exec flag for the
              duplicate descriptor.  Specifying this flag permits a program to avoid
              an additional <B>fcntl</B>() <B>F_SETFD</B> operation to set the <B>FD_CLOEXEC</B> flag.
              For an explanation of why this flag is useful, see the description of
              <B>O_CLOEXEC</B> in <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A>.
</PRE>
<H3>File descriptor flags</H3><PRE>       The following commands manipulate the flags associated with a file descriptor.
       Currently, only one such flag is defined: <B>FD_CLOEXEC</B>, the close-on-exec flag.
       If the <B>FD_CLOEXEC</B> bit is 0, the file descriptor will remain open across an
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html">execve(2)</A>, otherwise it will be closed.

       <B>F_GETFD</B> (<I>void</I>)
              Read the file descriptor flags; <I>arg</I> is ignored.

       <B>F_SETFD</B> (<I>long</I>)
              Set the file descriptor flags to the value specified by <I>arg</I>.
</PRE>
<H3>File status flags</H3><PRE>       Each open file description has certain associated status flags, initialized by
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A> and possibly modified by <B>fcntl</B>().  Duplicated file descriptors (made
       with <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup.2.html">dup(2)</A>, <B>fcntl</B>(F_DUPFD), <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html">fork(2)</A>, etc.) refer to the same open file
       description, and thus share the same file status flags.

       The file status flags and their semantics are described in <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A>.

       <B>F_GETFL</B> (<I>void</I>)
              Read the file status flags; <I>arg</I> is ignored.

       <B>F_SETFL</B> (<I>long</I>)
              Set the file status flags to the value specified by <I>arg</I>.  File access
              mode (<B>O_RDONLY</B>, <B>O_WRONLY</B>, <B>O_RDWR</B>) and file creation flags (i.e.,
              <B>O_CREAT</B>, <B>O_EXCL</B>, <B>O_NOCTTY</B>, <B>O_TRUNC</B>) in <I>arg</I> are ignored.  On Linux this
              command can only change the <B>O_APPEND</B>, <B>O_ASYNC</B>, <B>O_DIRECT</B>, <B>O_NOATIME</B>, and
              <B>O_NONBLOCK</B> flags.
</PRE>
<H3>Advisory locking</H3><PRE>       <B>F_GETLK</B>, <B>F_SETLK</B> and <B>F_SETLKW</B> are used to acquire, release, and test for the
       existence of record locks (also known as file-segment or file-region locks).
       The third argument, <I>lock</I>, is a pointer to a structure that has at least the
       following fields (in unspecified order).

           struct flock {
               ...
               short l_type;    /* Type of lock: F_RDLCK,
                                   F_WRLCK, F_UNLCK */
               short l_whence;  /* How to interpret l_start:
                                   SEEK_SET, SEEK_CUR, SEEK_END */
               off_t l_start;   /* Starting offset for lock */
               off_t l_len;     /* Number of bytes to lock */
               pid_t l_pid;     /* PID of process blocking our lock
                                   (F_GETLK only) */
               ...
           };

       The <I>l_whence</I>, <I>l_start</I>, and <I>l_len</I> fields of this structure specify the range of
       bytes we wish to lock.  Bytes past the end of the file may be locked, but not
       bytes before the start of the file.

       <I>l_start</I> is the starting offset for the lock, and is interpreted relative to
       either: the start of the file (if <I>l_whence</I> is <B>SEEK_SET</B>); the current file
       offset (if <I>l_whence</I> is <B>SEEK_CUR</B>); or the end of the file (if <I>l_whence</I> is
       <B>SEEK_END</B>).  In the final two cases, <I>l_start</I> can be a negative number provided
       the offset does not lie before the start of the file.

       <I>l_len</I> specifies the number of bytes to be locked.  If <I>l_len</I> is positive, then
       the range to be locked covers bytes <I>l_start</I> up to and including
       <I>l_start</I>+<I>l_len</I>-<I>1</I>.  Specifying 0 for <I>l_len</I> has the special meaning: lock all
       bytes starting at the location specified by <I>l_whence</I> and <I>l_start</I> through to
       the end of file, no matter how large the file grows.

       POSIX.1-2001 allows (but does not require) an implementation to support a
       negative <I>l_len</I> value; if <I>l_len</I> is negative, the interval described by <I>lock</I>
       covers bytes <I>l_start</I>+<I>l_len</I> up to and including <I>l_start</I>-1.  This is supported
       by Linux since kernel versions 2.4.21 and 2.5.49.

       The <I>l_type</I> field can be used to place a read (<B>F_RDLCK</B>) or a write (<B>F_WRLCK</B>)
       lock on a file.  Any number of processes may hold a read lock (shared lock) on
       a file region, but only one process may hold a write lock (exclusive lock).
       An exclusive lock excludes all other locks, both shared and exclusive.  A
       single process can hold only one type of lock on a file region; if a new lock
       is applied to an already-locked region, then the existing lock is converted to
       the new lock type.  (Such conversions may involve splitting, shrinking, or
       coalescing with an existing lock if the byte range specified by the new lock
       does not precisely coincide with the range of the existing lock.)

       <B>F_SETLK</B> (<I>struct</I> <I>flock</I> <I>*</I>)
              Acquire a lock (when <I>l_type</I> is <B>F_RDLCK</B> or <B>F_WRLCK</B>) or release a lock
              (when <I>l_type</I> is <B>F_UNLCK</B>) on the bytes specified by the <I>l_whence</I>,
              <I>l_start</I>, and <I>l_len</I> fields of <I>lock</I>.  If a conflicting lock is held by
              another process, this call returns -1 and sets <I>errno</I> to <B>EACCES</B> or
              <B>EAGAIN</B>.

       <B>F_SETLKW</B> (<I>struct</I> <I>flock</I> <I>*</I>)
              As for <B>F_SETLK</B>, but if a conflicting lock is held on the file, then
              wait for that lock to be released.  If a signal is caught while
              waiting, then the call is interrupted and (after the signal handler has
              returned) returns immediately (with return value -1 and <I>errno</I> set to
              <B>EINTR</B>; see <A href="http://www.kernel.org/doc/man-pages/online/pages/man7/signal.7.html">signal(7)</A>).

       <B>F_GETLK</B> (<I>struct</I> <I>flock</I> <I>*</I>)
              On input to this call, <I>lock</I> describes a lock we would like to place on
              the file.  If the lock could be placed, <B>fcntl</B>() does not actually place
              it, but returns <B>F_UNLCK</B> in the <I>l_type</I> field of <I>lock</I> and leaves the
              other fields of the structure unchanged.  If one or more incompatible
              locks would prevent this lock being placed, then <B>fcntl</B>() returns
              details about one of these locks in the <I>l_type</I>, <I>l_whence</I>, <I>l_start</I>, and
              <I>l_len</I> fields of <I>lock</I> and sets <I>l_pid</I> to be the PID of the process
              holding that lock.

       In order to place a read lock, <I>fd</I> must be open for reading.  In order to place
       a write lock, <I>fd</I> must be open for writing.  To place both types of lock, open
       a file read-write.

       As well as being removed by an explicit <B>F_UNLCK</B>, record locks are
       automatically released when the process terminates or if it closes <I>any</I> file
       descriptor referring to a file on which locks are held.  This is bad: it means
       that a process can lose the locks on a file like <I>/etc/passwd</I> or <I>/etc/mtab</I> when
       for some reason a library function decides to open, read and close it.

       Record locks are not inherited by a child created via <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html">fork(2)</A>, but are
       preserved across an <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/execve.2.html">execve(2)</A>.

       Because of the buffering performed by the <A href="http://www.kernel.org/doc/man-pages/online/pages/man3/stdio.3.html">stdio(3)</A> library, the use of record
       locking with routines in that package should be avoided; use <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html">read(2)</A> and
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/write.2.html">write(2)</A> instead.
</PRE>
<H3>Mandatory locking</H3><PRE>       (Non-POSIX.)  The above record locks may be either advisory or mandatory, and
       are advisory by default.

       Advisory locks are not enforced and are useful only between cooperating
       processes.

       Mandatory locks are enforced for all processes.  If a process tries to perform
       an incompatible access (e.g., <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html">read(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/write.2.html">write(2)</A>) on a file region that has
       an incompatible mandatory lock, then the result depends upon whether the
       <B>O_NONBLOCK</B> flag is enabled for its open file description.  If the <B>O_NONBLOCK</B>
       flag is not enabled, then system call is blocked until the lock is removed or
       converted to a mode that is compatible with the access.  If the <B>O_NONBLOCK</B>
       flag is enabled, then the system call fails with the error <B>EAGAIN</B> or
       <B>EWOULDBLOCK</B>.

       To make use of mandatory locks, mandatory locking must be enabled both on the
       file system that contains the file to be locked, and on the file itself.
       Mandatory locking is enabled on a file system using the "-o mand" option to
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man8/mount.8.html">mount(8)</A>, or the <B>MS_MANDLOCK</B> flag for <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/mount.2.html">mount(2)</A>.  Mandatory locking is enabled
       on a file by disabling group execute permission on the file and enabling the
       set-group-ID permission bit (see <A href="http://www.kernel.org/doc/man-pages/online/pages/man1/chmod.1.html">chmod(1)</A> and <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/chmod.2.html">chmod(2)</A>).

       The Linux implementation of mandatory locking is unreliable.  See BUGS below.
</PRE>
<H3>Managing signals</H3><PRE>       <B>F_GETOWN</B>, <B>F_SETOWN</B>, <B>F_GETSIG</B> and <B>F_SETSIG</B> are used to manage I/O availability
       signals:

       <B>F_GETOWN</B> (<I>void</I>)
              Return (as the function result) the process ID or process group
              currently receiving <B>SIGIO</B> and <B>SIGURG</B> signals for events on file
              descriptor <I>fd</I>.  Process IDs are returned as positive values; process
              group IDs are returned as negative values (but see BUGS below).  <I>arg</I> is
              ignored.

       <B>F_SETOWN</B> (<I>long</I>)
              Set the process ID or process group ID that will receive <B>SIGIO</B> and
              <B>SIGURG</B> signals for events on file descriptor <I>fd</I> to the ID given in <I>arg</I>.
              A process ID is specified as a positive value; a process group ID is
              specified as a negative value.  Most commonly, the calling process
              specifies itself as the owner (that is, <I>arg</I> is specified as <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpid.2.html">getpid(2)</A>).

              If you set the <B>O_ASYNC</B> status flag on a file descriptor by using the
              <B>F_SETFL</B> command of <B>fcntl</B>(), a <B>SIGIO</B> signal is sent whenever input or
              output becomes possible on that file descriptor.  <B>F_SETSIG</B> can be used
              to obtain delivery of a signal other than <B>SIGIO</B>.  If this permission
              check fails, then the signal is silently discarded.

              Sending a signal to the owner process (group) specified by <B>F_SETOWN</B> is
              subject to the same permissions checks as are described for <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/kill.2.html">kill(2)</A>,
              where the sending process is the one that employs <B>F_SETOWN</B> (but see
              BUGS below).

              If the file descriptor <I>fd</I> refers to a socket, <B>F_SETOWN</B> also selects the
              recipient of <B>SIGURG</B> signals that are delivered when out-of-band data
              arrives on that socket.  (<B>SIGURG</B> is sent in any situation where
              <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html">select(2)</A> would report the socket as having an "exceptional
              condition".)

              If a non-zero value is given to <B>F_SETSIG</B> in a multithreaded process
              running with a threading library that supports thread groups (e.g.,
              NPTL), then a positive value given to <B>F_SETOWN</B> has a different meaning:
              instead of being a process ID identifying a whole process, it is a
              thread ID identifying a specific thread within a process.
              Consequently, it may be necessary to pass <B>F_SETOWN</B> the result of
              <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/gettid.2.html">gettid(2)</A> instead of <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpid.2.html">getpid(2)</A> to get sensible results when <B>F_SETSIG</B> is
              used.  (In current Linux threading implementations, a main thread's
              thread ID is the same as its process ID.  This means that a single-
              threaded program can equally use <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/gettid.2.html">gettid(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/getpid.2.html">getpid(2)</A> in this
              scenario.)  Note, however, that the statements in this paragraph do not
              apply to the <B>SIGURG</B> signal generated for out-of-band data on a socket:
              this signal is always sent to either a process or a process group,
              depending on the value given to <B>F_SETOWN</B>.  Note also that Linux imposes
              a limit on the number of real-time signals that may be queued to a
              process (see <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/getrlimit.2.html">getrlimit(2)</A> and <A href="http://www.kernel.org/doc/man-pages/online/pages/man7/signal.7.html">signal(7)</A>) and if this limit is reached,
              then the kernel reverts to delivering <B>SIGIO</B>, and this signal is
              delivered to the entire process rather than to a specific thread.

       <B>F_GETSIG</B> (<I>void</I>)
              Return (as the function result) the signal sent when input or output
              becomes possible.  A value of zero means <B>SIGIO</B> is sent.  Any other
              value (including <B>SIGIO</B>) is the signal sent instead, and in this case
              additional info is available to the signal handler if installed with
              <B>SA_SIGINFO</B>.  <I>arg</I> is ignored.

       <B>F_SETSIG</B> (<I>long</I>)
              Set the signal sent when input or output becomes possible to the value
              given in <I>arg</I>.  A value of zero means to send the default <B>SIGIO</B> signal.
              Any other value (including <B>SIGIO</B>) is the signal to send instead, and in
              this case additional info is available to the signal handler if
              installed with <B>SA_SIGINFO</B>.

              Additionally, passing a non-zero value to <B>F_SETSIG</B> changes the signal
              recipient from a whole process to a specific thread within a process.
              See the description of <B>F_SETOWN</B> for more details.

              By using <B>F_SETSIG</B> with a non-zero value, and setting <B>SA_SIGINFO</B> for the
              signal handler (see <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/sigaction.2.html">sigaction(2)</A>), extra information about I/O events
              is passed to the handler in a <I>siginfo_t</I> structure.  If the <I>si_code</I>
              field indicates the source is <B>SI_SIGIO</B>, the <I>si_fd</I> field gives the file
              descriptor associated with the event.  Otherwise, there is no
              indication which file descriptors are pending, and you should use the
              usual mechanisms (<A href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html">select(2)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html">poll(2)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html">read(2)</A> with <B>O_NONBLOCK</B> set etc.)
              to determine which file descriptors are available for I/O.

              By selecting a real time signal (value &gt;= <B>SIGRTMIN</B>), multiple I/O
              events may be queued using the same signal numbers.  (Queuing is
              dependent on available memory).  Extra information is available if
              <B>SA_SIGINFO</B> is set for the signal handler, as above.

       Using these mechanisms, a program can implement fully asynchronous I/O without
       using <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/select.2.html">select(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/poll.2.html">poll(2)</A> most of the time.

       The use of <B>O_ASYNC</B>, <B>F_GETOWN</B>, <B>F_SETOWN</B> is specific to BSD and Linux.  <B>F_GETSIG</B>
       and <B>F_SETSIG</B> are Linux-specific.  POSIX has asynchronous I/O and the
       <I>aio_sigevent</I> structure to achieve similar things; these are also available in
       Linux as part of the GNU C Library (Glibc).
</PRE>
<H3>Leases</H3><PRE>       <B>F_SETLEASE</B> and <B>F_GETLEASE</B> (Linux 2.4 onwards) are used (respectively) to
       establish a new lease, and retrieve the current lease, on the open file
       description referred to by the file descriptor <I>fd</I>.  A file lease provides a
       mechanism whereby the process holding the lease (the "lease holder") is
       notified (via delivery of a signal) when a process (the "lease breaker") tries
       to <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate.2.html">truncate(2)</A> the file referred to by that file descriptor.

       <B>F_SETLEASE</B> (<I>long</I>)
              Set or remove a file lease according to which of the following values
              is specified in the integer <I>arg</I>:

              <B>F_RDLCK</B>
                     Take out a read lease.  This will cause the calling process to
                     be notified when the file is opened for writing or is truncated.
                     A read lease can only be placed on a file descriptor that is
                     opened read-only.

              <B>F_WRLCK</B>
                     Take out a write lease.  This will cause the caller to be
                     notified when the file is opened for reading or writing or is
                     truncated.  A write lease may be placed on a file only if there
                     are no other open file descriptors for the file.

              <B>F_UNLCK</B>
                     Remove our lease from the file.

       Leases are associated with an open file description (see <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A>).  This means
       that duplicate file descriptors (created by, for example, <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/fork.2.html">fork(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup.2.html">dup(2)</A>)
       refer to the same lease, and this lease may be modified or released using any
       of these descriptors.  Furthermore, the lease is released by either an
       explicit <B>F_UNLCK</B> operation on any of these duplicate descriptors, or when all
       such descriptors have been closed.

       Leases may only be taken out on regular files.  An unprivileged process may
       only take out a lease on a file whose UID (owner) matches the file system UID
       of the process.  A process with the <B>CAP_LEASE</B> capability may take out leases
       on arbitrary files.

       <B>F_GETLEASE</B> (<I>void</I>)
              Indicates what type of lease is associated with the file descriptor <I>fd</I>
              by returning either <B>F_RDLCK</B>, <B>F_WRLCK</B>, or <B>F_UNLCK</B>, indicating,
              respectively, a read lease , a write lease, or no lease.  <I>arg</I> is
              ignored.

       When a process (the "lease breaker") performs an <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate.2.html">truncate(2)</A> that
       conflicts with a lease established via <B>F_SETLEASE</B>, the system call is blocked
       by the kernel and the kernel notifies the lease holder by sending it a signal
       (<B>SIGIO</B> by default).  The lease holder should respond to receipt of this signal
       by doing whatever cleanup is required in preparation for the file to be
       accessed by another process (e.g., flushing cached buffers) and then either
       remove or downgrade its lease.  A lease is removed by performing an <B>F_SETLEASE</B>
       command specifying <I>arg</I> as <B>F_UNLCK</B>.  If the lease holder currently holds a
       write lease on the file, and the lease breaker is opening the file for
       reading, then it is sufficient for the lease holder to downgrade the lease to
       a read lease.  This is done by performing an <B>F_SETLEASE</B> command specifying <I>arg</I>
       as <B>F_RDLCK</B>.

       If the lease holder fails to downgrade or remove the lease within the number
       of seconds specified in <I>/proc/sys/fs/lease-break-time</I> then the kernel forcibly
       removes or downgrades the lease holder's lease.

       Once the lease has been voluntarily or forcibly removed or downgraded, and
       assuming the lease breaker has not unblocked its system call, the kernel
       permits the lease breaker's system call to proceed.

       If the lease breaker's blocked <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate.2.html">truncate(2)</A> is interrupted by a
       signal handler, then the system call fails with the error <B>EINTR</B>, but the other
       steps still occur as described above.  If the lease breaker is killed by a
       signal while blocked in <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A> or <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/truncate.2.html">truncate(2)</A>, then the other steps still
       occur as described above.  If the lease breaker specifies the <B>O_NONBLOCK</B> flag
       when calling <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A>, then the call immediately fails with the error
       <B>EWOULDBLOCK</B>, but the other steps still occur as described above.

       The default signal used to notify the lease holder is <B>SIGIO</B>, but this can be
       changed using the <B>F_SETSIG</B> command to <B>fcntl</B>().  If a <B>F_SETSIG</B> command is
       performed (even one specifying <B>SIGIO</B>), and the signal handler is established
       using <B>SA_SIGINFO</B>, then the handler will receive a <I>siginfo_t</I> structure as its
       second argument, and the <I>si_fd</I> field of this argument will hold the descriptor
       of the leased file that has been accessed by another process.  (This is useful
       if the caller holds leases against multiple files).
</PRE>
<H3>File and directory change notification (dnotify)</H3><PRE>       <B>F_NOTIFY</B> (<I>long</I>)
              (Linux 2.4 onwards) Provide notification when the directory referred to
              by <I>fd</I> or any of the files that it contains is changed.  The events to
              be notified are specified in <I>arg</I>, which is a bit mask specified by
              ORing together zero or more of the following bits:

              <B>DN_ACCESS</B>   A file was accessed (read, pread, readv)
              <B>DN_MODIFY</B>   A file was modified (write, pwrite, writev, truncate,
                          ftruncate).
              <B>DN_CREATE</B>   A file was created (open, creat, mknod, mkdir, link,
                          symlink, rename).
              <B>DN_DELETE</B>   A file was unlinked (unlink, rename to another directory,
                          rmdir).
              <B>DN_RENAME</B>   A file was renamed within this directory (rename).
              <B>DN_ATTRIB</B>   The attributes of a file were changed (chown, chmod,
                          utime[s]).

              (In order to obtain these definitions, the <B>_GNU_SOURCE</B> feature test
              macro must be defined.)

              Directory notifications are normally "one-shot", and the application
              must re-register to receive further notifications.  Alternatively, if
              <B>DN_MULTISHOT</B> is included in <I>arg</I>, then notification will remain in
              effect until explicitly removed.

              A series of <B>F_NOTIFY</B> requests is cumulative, with the events in <I>arg</I>
              being added to the set already monitored.  To disable notification of
              all events, make an <B>F_NOTIFY</B> call specifying <I>arg</I> as 0.

              Notification occurs via delivery of a signal.  The default signal is
              <B>SIGIO</B>, but this can be changed using the <B>F_SETSIG</B> command to <B>fcntl</B>().
              In the latter case, the signal handler receives a <I>siginfo_t</I> structure
              as its second argument (if the handler was established using
              <B>SA_SIGINFO</B>) and the <I>si_fd</I> field of this structure contains the file
              descriptor which generated the notification (useful when establishing
              notification on multiple directories).

              Especially when using <B>DN_MULTISHOT</B>, a real time signal should be used
              for notification, so that multiple notifications can be queued.

              <B>NOTE:</B> New applications should use the <I>inotify</I> interface (available
              since kernel 2.6.13), which provides a much superior interface for
              obtaining notifications of file system events.  See <A href="http://www.kernel.org/doc/man-pages/online/pages/man7/inotify.7.html">inotify(7)</A>.
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#RETURN_VALUE" 
name=RETURN_VALUE></A>
<H2>RETURN VALUE &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       For a successful call, the return value depends on the operation:

       <B>F_DUPFD</B>  The new descriptor.

       <B>F_GETFD</B>  Value of flags.

       <B>F_GETFL</B>  Value of flags.

       <B>F_GETLEASE</B>
                Type of lease held on file descriptor.

       <B>F_GETOWN</B> Value of descriptor owner.

       <B>F_GETSIG</B> Value of signal sent when read or write becomes possible, or zero for
                traditional <B>SIGIO</B> behavior.

       All other commands
                Zero.

       On error, -1 is returned, and <I>errno</I> is set appropriately.
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#ERRORS" 
name=ERRORS></A>
<H2>ERRORS &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       <B>EACCES</B> or <B>EAGAIN</B>
              Operation is prohibited by locks held by other processes.

       <B>EAGAIN</B> The operation is prohibited because the file has been memory-mapped by
              another process.

       <B>EBADF</B>  <I>fd</I> is not an open file descriptor, or the command was <B>F_SETLK</B> or
              <B>F_SETLKW</B> and the file descriptor open mode doesn't match with the type
              of lock requested.

       <B>EDEADLK</B>
              It was detected that the specified <B>F_SETLKW</B> command would cause a
              deadlock.

       <B>EFAULT</B> <I>lock</I> is outside your accessible address space.

       <B>EINTR</B>  For <B>F_SETLKW</B>, the command was interrupted by a signal; see <A href="http://www.kernel.org/doc/man-pages/online/pages/man7/signal.7.html">signal(7)</A>.
              For <B>F_GETLK</B> and <B>F_SETLK</B>, the command was interrupted by a signal before
              the lock was checked or acquired.  Most likely when locking a remote
              file (e.g., locking over NFS), but can sometimes happen locally.

       <B>EINVAL</B> For <B>F_DUPFD</B>, <I>arg</I> is negative or is greater than the maximum allowable
              value.  For <B>F_SETSIG</B>, <I>arg</I> is not an allowable signal number.

       <B>EMFILE</B> For <B>F_DUPFD</B>, the process already has the maximum number of file
              descriptors open.

       <B>ENOLCK</B> Too many segment locks open, lock table is full, or a remote locking
              protocol failed (e.g., locking over NFS).

       <B>EPERM</B>  Attempted to clear the <B>O_APPEND</B> flag on a file that has the append-only
              attribute set.
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#CONFORMING_TO" 
name=CONFORMING_TO></A>
<H2>CONFORMING TO &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       SVr4, 4.3BSD, POSIX.1-2001.  Only the operations <B>F_DUPFD</B>, <B>F_GETFD</B>, <B>F_SETFD</B>,
       <B>F_GETFL</B>, <B>F_SETFL</B>, <B>F_GETLK</B>, <B>F_SETLK</B>, <B>F_SETLKW</B>, <B>F_GETOWN</B>, and <B>F_SETOWN</B> are
       specified in POSIX.1-2001.

       <B>F_DUPFD_CLOEXEC</B> is specified in POSIX.1-2008.

       <B>F_GETSIG</B>, <B>F_SETSIG</B>, <B>F_NOTIFY</B>, <B>F_GETLEASE</B>, and <B>F_SETLEASE</B> are Linux-specific.
       (Define the <B>_GNU_SOURCE</B> macro to obtain these definitions.)
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#NOTES" 
name=NOTES></A>
<H2>NOTES &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       The errors returned by <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup2.2.html">dup2(2)</A> are different from those returned by <B>F_DUPFD</B>.

       Since kernel 2.0, there is no interaction between the types of lock placed by
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/flock.2.html">flock(2)</A> and <B>fcntl</B>().

       Several systems have more fields in <I>struct</I> <I>flock</I> such as, for example,
       <I>l_sysid</I>.  Clearly, <I>l_pid</I> alone is not going to be very useful if the process
       holding the lock may live on a different machine.
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#BUGS" 
name=BUGS></A>
<H2>BUGS &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       A limitation of the Linux system call conventions on some architectures
       (notably i386) means that if a (negative) process group ID to be returned by
       <B>F_GETOWN</B> falls in the range -1 to -4095, then the return value is wrongly
       interpreted by glibc as an error in the system call; that is, the return value
       of <B>fcntl</B>() will be -1, and <I>errno</I> will contain the (positive) process group ID.

       In Linux 2.4 and earlier, there is bug that can occur when an unprivileged
       process uses <B>F_SETOWN</B> to specify the owner of a socket file descriptor as a
       process (group) other than the caller.  In this case, <B>fcntl</B>() can return -1
       with <I>errno</I> set to <B>EPERM</B>, even when the owner process (group) is one that the
       caller has permission to send signals to.  Despite this error return, the file
       descriptor owner is set, and signals will be sent to the owner.

       The implementation of mandatory locking in all known versions of Linux is
       subject to race conditions which render it unreliable: a <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/write.2.html">write(2)</A> call that
       overlaps with a lock may modify data after the mandatory lock is acquired; a
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/read.2.html">read(2)</A> call that overlaps with a lock may detect changes to data that were
       made only after a write lock was acquired.  Similar races exist between
       mandatory locks and <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/mmap.2.html">mmap(2)</A>.  It is therefore inadvisable to rely on mandatory
       locking.
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#SEE_ALSO" 
name=SEE_ALSO></A>
<H2>SEE ALSO &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/dup2.2.html">dup2(2)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/flock.2.html">flock(2)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/open.2.html">open(2)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man2/socket.2.html">socket(2)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man3/lockf.3.html">lockf(3)</A>, <A href="http://www.kernel.org/doc/man-pages/online/pages/man7/capabilities.7.html">capabilities(7)</A>,
       <A href="http://www.kernel.org/doc/man-pages/online/pages/man7/feature_test_macros.7.html">feature_test_macros(7)</A>

       See also <I>Documentation/locks.txt</I>, <I>Documentation/mandatory.txt</I>, and
       <I>Documentation/dnotify.txt</I> in the kernel source.
</PRE><A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#COLOPHON" 
name=COLOPHON></A>
<H2>COLOPHON &nbsp; &nbsp; &nbsp; &nbsp; <A 
href="http://www.kernel.org/doc/man-pages/online/pages/man2/fcntl.2.html#section_dir"><FONT 
size=-2>top</FONT></A></H2><PRE>       This page is part of release 3.15 of the Linux <I>man-pages</I> project.  A
       description of the project, and information about reporting bugs, can be found
       at <A href="http://www.kernel.org/doc/man-pages/">http://www.kernel.org/doc/man-pages/</A>.

Linux                                 2008-09-05                             FCNTL(2)
</PRE>
<HR>
</PR></BODY></HTML>
