##############################################################################
#                                                                            #
# IAR Atmel AVR C/C++ Compiler V4.11A/W32              17/Jan/2006  19:30:50 #
# Copyright 1996-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  C:\Documents and Settings\andeaper\My                   #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\main.c                              #
#    Command line =  "C:\Documents and Settings\andeaper\My                  #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\main.c" --cpu=m2560 -ms -o          #
#                    "C:\Documents and Settings\andeaper\My                  #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\Release\Obj\" -lCN "C:\Documents    #
#                    and Settings\andeaper\My Documents\QVCS\Appnotes\AVR109 #
#                     Self Programming\Source Code\IAR\ATmega2560\Release\Li #
#                    st\" -y --initializers_in_flash -z6 --no_inline         #
#                    --no_cross_call --no_tbaa --cross_call_passes=4         #
#                    --debug -DENABLE_BIT_DEFINITIONS --do_cross_call -e -I  #
#                    "C:\Program Files\IAR Systems\Embedded Workbench        #
#                    4.0\avr\INC\" -I "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 4.0\avr\INC\CLIB\"           #
#                    --eeprom_size 4096                                      #
#    List file    =  C:\Documents and Settings\andeaper\My                   #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\Release\List\main.lst               #
#    Object file  =  C:\Documents and Settings\andeaper\My                   #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\Release\Obj\main.r90                #
#                                                                            #
#                                                                            #
##############################################################################

C:\Documents and Settings\andeaper\My Documents\QVCS\Appnotes\AVR109 Self Programming\Source Code\IAR\ATmega2560\main.c
      1          /*****************************************************************************
      2          *
      3          * Atmel Corporation
      4          *
      5          * File              : main.c
      6          * Compiler          : IAR C 3.10C Kickstart
      7          * Revision          : $Revision: 2.0 $
      8          * Date              : $Date: Tuesday, November 29, $
      9          * Updated by        : $Author: raapeland $
     10          *
     11          * Support mail      : avr@atmel.com
     12          *
     13          * Target platform   : All AVRs with bootloader support
     14          *
     15          * AppNote           : AVR109 - Self-programming
     16          *
     17          * Description   : This Program allows an AVR with bootloader capabilities to
     18          *                 Read/write its own Flash/EEprom. To enter Programming mode
     19          *                 an input pin is checked. If this pin is pulled low, programming mode
     20          *                 is entered. If not, normal execution is done from $0000
     21          *                 "reset" vector in Application area.
     22          *
     23          * Preparations  : Use the preprocessor.xls file for obtaining a customized
     24          *                 defines.h file and linker-file code-segment definition for
     25          *                 the device you are compiling for.
     26          ****************************************************************************/
     27          #include <inavr.h>
     28          #include "defines.h"

   \                                 In segment ABSOLUTE, at 0x57
   \   union <unnamed> volatile __io _A_SPMCSR
   \                     _A_SPMCSR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS 2

   \                                 In segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x29
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                      DS 1
     29          #include "serial.h"
     30          #include "flash.h"
     31          
     32          
     33          #ifndef EEWE
     34            #define EEWE EEPE
     35          #endif
     36          #ifndef EEMWE
     37            #define EEMWE EEMPE
     38          #endif
     39          
     40          /*** WARNING: The AVRprog application in AVR Studio does not support block mode,
     41               but it will try to use it anyway. Therefore, block mode must be disabled below
     42               if AVRprog is going to be used. ***/
     43          
     44          
     45          /* Uncomment the following to save code space */
     46          #define REMOVE_AVRPROG_SUPPORT
     47          //#define REMOVE_FUSE_AND_LOCK_BIT_SUPPORT
     48          //#define REMOVE_BLOCK_SUPPORT
     49          //#define REMOVE_EEPROM_BYTE_SUPPORT
     50          //#define REMOVE_FLASH_BYTE_SUPPORT
     51          
     52          
     53          
     54          #ifndef REMOVE_BLOCK_SUPPORT
     55          unsigned char BlockLoad(unsigned int size, unsigned char mem, long *address);
     56          void BlockRead(unsigned int size, unsigned char mem, long *address);
     57          
     58          /* BLOCKSIZE should be chosen so that the following holds: BLOCKSIZE*n = PAGESIZE,  where n=1,2,3... */
     59          #define BLOCKSIZE PAGESIZE
     60          
     61          #endif
     62          
     63          
     64          

   \                                 In segment FARCODE, align 2, keep-with-next
     65          __C_task void main(void)
   \                     main:
     66          {
   \   00000000   9724               SBIW    R29:R28, 4
     67          	long address;
     68          	unsigned int temp_int;
     69          	unsigned char val;
     70          
     71          
     72          	/* Initialization */
     73          	void (*funcptr)( void ) = 0x0000; // Set up function pointer to RESET vector.
     74          	PROGPORT |= (1<<PROG_NO); // Enable pull-up on PROG_NO line on PROGPORT.
   \   00000002   9A5C               SBI     0x0B, 0x04
     75          	initbootuart(); // Initialize UART.
   \   00000004   ........           CALL    initbootuart
     76          
     77          	/* Branch to bootloader or application code? */
     78          	if( !(PROGPIN & (1<<PROG_NO)) ) // If PROGPIN is pulled low, enter programmingmode.
   \   00000008   9B4C               SBIS    0x09, 0x04
   \   0000000A   C011               RJMP    ??main_0
     79          	{
     80          		/* Main loop */
     81          		for(;;)
     82          		{
     83          			val=recchar(); // Wait for command character.
     84          
     85          			// Check autoincrement status.
     86          			if(val=='a')
     87          			{
     88          				sendchar('Y'); // Yes, we do autoincrement.
     89          			}
     90          
     91          
     92          			// Set address.
     93          			else if(val=='A') // Set address...
     94          			{ // NOTE: Flash addresses are given in words, not bytes.
     95          				unsigned char high = recchar();
     96          				unsigned char low = recchar();
     97          				address = ((long)high<<8) | (long)low;
     98          				sendchar('\r'); // Send OK back.
     99          			}
    100          
    101          			// Set 24-bit address.
    102          			else if(val=='H')
    103          			{ // NOTE: Flash addresses are given in words, not bytes.
    104          				unsigned char highest = recchar();
    105          				unsigned char high = recchar();
    106          				unsigned char low = recchar();
    107          				address = ((long)highest << 16) | ((long)high << 8) | (long)low;
    108          				sendchar('\r'); // Send OK back.
    109          			}
    110          
    111          			// Chip erase.
    112          			else if(val=='e')
    113          			{
    114          				for(address = 0; address < APP_END;address += PAGESIZE)
    115          				{ // NOTE: Here we use address as a byte-address, not word-address, for convenience.
    116          					_WAIT_FOR_SPM();
    117          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    118          					_PAGE_ERASE( address );
    119          #pragma diag_default=Pe1053 // Back to default.
    120          				}
    121          
    122          				sendchar('\r'); // Send OK back.
    123          			}
    124          
    125          #ifndef REMOVE_BLOCK_SUPPORT
    126          			// Check block load support.
    127          			else if(val=='b')
    128          			{
    129          				sendchar('Y'); // Report block load supported.
    130          				sendchar((BLOCKSIZE>>8) & 0xFF); // MSB first.
    131          				sendchar(BLOCKSIZE&0xFF); // Report BLOCKSIZE (bytes).
    132          			}
    133          
    134          
    135          			// Start block load.
    136          			else if(val=='B')
    137          			{
    138          				temp_int = (recchar()<<8) | recchar(); // Get block size.
    139          				val = recchar(); // Get memtype.
    140          				sendchar( BlockLoad(temp_int,val,&address) ); // Block load.
    141          			}
    142          
    143          
    144          			// Start block read.
    145          			else if(val=='g')
    146          			{
    147          				temp_int = (recchar()<<8) | recchar(); // Get block size.
    148          				val = recchar(); // Get memtype
    149          				BlockRead(temp_int,val,&address); // Block read
    150          			}
    151          #endif
    152          
    153          #ifndef REMOVE_FLASH_BYTE_SUPPORT
    154          			// Read program memory.
    155          			else if(val=='R')
    156          			{
    157          				// Send high byte, then low byte of flash word.
    158          				_WAIT_FOR_SPM();
    159          				_ENABLE_RWW_SECTION();
    160          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    161          				sendchar( _LOAD_PROGRAM_MEMORY( (address << 1)+1 ) );
    162          				sendchar( _LOAD_PROGRAM_MEMORY( (address << 1)+0 ) );
    163          #pragma diag_default=Pe1053 // Back to default.
    164          
    165          				address++; // Auto-advance to next Flash word.
    166          			}
    167          
    168          
    169          			// Write program memory, low byte.
    170          			else if(val=='c')
    171          			{ // NOTE: Always use this command before sending high byte.
    172          				temp_int=recchar(); // Get low byte for later _FILL_TEMP_WORD.
    173          				sendchar('\r'); // Send OK back.
    174          			}
    175          
    176          
    177          			// Write program memory, high byte.
    178          			else if(val=='C')
    179          			{
    180          				temp_int |= (recchar()<<8); // Get and insert high byte.
    181          				_WAIT_FOR_SPM();
    182          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    183          				_FILL_TEMP_WORD( (address << 1), temp_int ); // Convert word-address to byte-address and fill.
    184          #pragma diag_default=Pe1053 // Back to default.
    185          				address++; // Auto-advance to next Flash word.
    186          				sendchar('\r'); // Send OK back.
    187          			}
    188          
    189          
    190          			// Write page.
    191          			else if(val== 'm')
    192          			{
    193          				if( address >= (APP_END>>1) ) // Protect bootloader area.
    194          				{
    195          					sendchar('?');
    196          				} else
    197          				{
    198          					_WAIT_FOR_SPM();
    199          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    200          					_PAGE_WRITE( address << 1 ); // Convert word-address to byte-address and write.
    201          #pragma diag_default=Pe1053 // Back to default.
    202          				}
    203          
    204          				sendchar('\r'); // Send OK back.
    205          			}
    206          #endif
    207          
    208          #ifndef REMOVE_EEPROM_BYTE_SUPPORT
    209          			// Write EEPROM memory.
    210          			else if (val == 'D')
    211          			{
    212          				_WAIT_FOR_SPM();
    213          				EEARL = address; // Setup EEPROM address.
    214          				EEARH = (address >> 8);
    215          				EEDR = recchar(); // Get byte.
    216          				EECR |= (1<<EEMWE); // Write byte.
    217          				EECR |= (1<<EEWE);
    218          				while (EECR & (1<<EEWE)) // Wait for write operation to finish.
    219          					;
    220          
    221          				address++; // Auto-advance to next EEPROM byte.
    222          				sendchar('\r');// Send OK back.
    223          			}
    224          
    225          
    226          			// Read EEPROM memory.
    227          			else if (val == 'd')
    228          			{
    229          				EEARL = address; // Setup EEPROM address.
    230          				EEARH = (address >> 8);
    231          				EECR |= (1<<EERE); // Read byte...
    232          				sendchar(EEDR); // ...and send it back.
    233          				address++; // Auto-advance to next EEPROM byte.
    234          			}
    235          #endif
    236          
    237          #ifndef REMOVE_FUSE_AND_LOCK_BIT_SUPPORT
    238          			// Write lockbits.
    239          			else if(val=='l')
    240          			{
    241          				_WAIT_FOR_SPM();
    242          				_SET_LOCK_BITS( recchar() ); // Read and set lock bits.
    243          				sendchar('\r'); // Send OK back.
    244          			}
    245          
    246          
    247          			// Read lock bits.
    248          			else if(val=='r')
    249          			{
    250          				_WAIT_FOR_SPM();
    251          				sendchar( _GET_LOCK_BITS() );
    252          			}
    253          
    254          
    255          			// Read fuse bits.
    256          			else if(val=='F')
    257          			{
    258          				_WAIT_FOR_SPM();
    259          				sendchar( _GET_LOW_FUSES() );
    260          			}
    261          
    262          
    263          			// Read high fuse bits.
    264          			else if(val=='N')
    265          			{
    266          				_WAIT_FOR_SPM();
    267          				sendchar( _GET_HIGH_FUSES() );
    268          			}
    269          
    270          
    271          			// Read extended fuse bits.
    272          			else if(val=='Q')
    273          			{
    274          				_WAIT_FOR_SPM();
    275          				sendchar( _GET_EXTENDED_FUSES() );
    276          			}
    277          #endif
    278          
    279          #ifndef REMOVE_AVRPROG_SUPPORT
    280          			// Enter and leave programming mode.
    281          			else if((val=='P')||(val=='L'))
    282          			{
    283          				sendchar('\r'); // Nothing special to do, just answer OK.
    284          			}
    285          
    286          
    287          			// Exit bootloader.
    288          			else if(val=='E')
    289          			{
    290          				_WAIT_FOR_SPM();
    291          				_ENABLE_RWW_SECTION();
    292          				sendchar('\r');
    293          				funcptr(); // Jump to Reset vector 0x0000 in Application Section.
    294          			}
    295          
    296          
    297          			// Get programmer type.
    298          			else if (val=='p')
    299          			{
    300          				sendchar('S'); // Answer 'SERIAL'.
    301          			}
    302          
    303          
    304          			// Return supported device codes.
    305          			else if(val=='t')
    306          			{
    307          				sendchar( PARTCODE ); // Supports only this device, of course.
    308          				sendchar( 0 ); // Send list terminator.
    309          			}
    310          
    311          
    312          			// Set LED, clear LED and set device type.
    313          			else if((val=='x')||(val=='y')||(val=='T'))
    314          			{
    315          				recchar(); // Ignore the command and it's parameter.
    316          				sendchar('\r'); // Send OK back.
    317          			}
    318          #endif
    319          
    320          			// Return programmer identifier.
    321          			else if(val=='S')
    322          			{
    323          				sendchar('A'); // Return 'AVRBOOT'.
    324          				sendchar('V'); // Software identifier (aka programmer signature) is always 7 characters.
    325          				sendchar('R');
    326          				sendchar('B');
    327          				sendchar('O');
    328          				sendchar('O');
    329          				sendchar('T');
    330          			}
    331          
    332          
    333          			// Return software version.
    334          			else if(val=='V')
    335          			{
    336          				sendchar('1');
    337          				sendchar('5');
    338          			}
    339          
    340          
    341          			// Return signature bytes.
    342          			else if(val=='s')
    343          			{
    344          				sendchar( SIGNATURE_BYTE_3 );
    345          				sendchar( SIGNATURE_BYTE_2 );
    346          				sendchar( SIGNATURE_BYTE_1 );
    347          			}
    348          
    349          
    350          			// The last command to accept is ESC (synchronization).
    351          			else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
    352          			{
    353          				sendchar('?');
    354          			}
    355          		} // end: for(;;)
    356          	}
    357          	else
    358          	{
    359          		_WAIT_FOR_SPM();
   \                     ??main_1:
   \   0000000C   B707               IN      R16, 0x37
   \   0000000E   2F10               MOV     R17, R16
   \   00000010   FD10               SBRC    R17, 0
   \   00000012   CFFC               RJMP    ??main_1
    360          		_ENABLE_RWW_SECTION();
   \   00000014   E111               LDI     R17, 17
   \   00000016   2400               CLR     R0
   \   00000018   BF17               OUT     0x37, R17
   \   0000001A   95E8               SPM
    361          		funcptr(); // Jump to Reset vector 0x0000 in Application Section.
   \   0000001C   E0E0               LDI     R30, 0
   \   0000001E   E0F0               LDI     R31, 0
   \   00000020   BFEC               OUT     0x3C, R30
   \   00000022   9519               EICALL
    362          	}
    363          } // end: main
   \   00000024   9624               ADIW    R29:R28, 4
   \   00000026   9508               RET
   \                     ??main_2:
   \   00000028   E509               LDI     R16, 89
   \                     ??main_3:
   \   0000002A   ........           CALL    sendchar
   \                     ??main_0:
   \   0000002E   ........           CALL    recchar
   \   00000032   3601               CPI     R16, 97
   \   00000034   F3C9               BREQ    ??main_2
   \   00000036   3401               CPI     R16, 65
   \   00000038   F459               BRNE    ??main_4
   \   0000003A   ........           CALL    recchar
   \   0000003E   2FA0               MOV     R26, R16
   \   00000040   ........           CALL    recchar
   \   00000044   E020               LDI     R18, 0
   \   00000046   8308               ST      Y, R16
   \   00000048   83A9               STD     Y+1, R26
   \   0000004A   832A               STD     Y+2, R18
   \   0000004C   832B               STD     Y+3, R18
   \   0000004E   C03C               RJMP    ??main_5
   \                     ??main_4:
   \   00000050   3408               CPI     R16, 72
   \   00000052   F471               BRNE    ??main_6
   \   00000054   ........           CALL    recchar
   \   00000058   2FB0               MOV     R27, R16
   \   0000005A   ........           CALL    recchar
   \   0000005E   2FA0               MOV     R26, R16
   \   00000060   ........           CALL    recchar
   \   00000064   E030               LDI     R19, 0
   \   00000066   8308               ST      Y, R16
   \   00000068   83A9               STD     Y+1, R26
   \   0000006A   83BA               STD     Y+2, R27
   \                     ??main_7:
   \   0000006C   833B               STD     Y+3, R19
   \   0000006E   C02C               RJMP    ??main_5
   \                     ??main_6:
   \   00000070   3605               CPI     R16, 101
   \   00000072   F561               BRNE    ??main_8
   \   00000074   E000               LDI     R16, 0
   \   00000076   8308               ST      Y, R16
   \   00000078   8309               STD     Y+1, R16
   \   0000007A   830A               STD     Y+2, R16
   \   0000007C   830B               STD     Y+3, R16
   \   0000007E   C018               RJMP    ??main_9
   \                     ??main_10:
   \   00000080   B707               IN      R16, 0x37
   \   00000082   2F10               MOV     R17, R16
   \   00000084   FD10               SBRC    R17, 0
   \   00000086   CFFC               RJMP    ??main_10
   \   00000088   E003               LDI     R16, 3
   \   0000008A   8148               LD      R20, Y
   \   0000008C   8159               LDD     R21, Y+1
   \   0000008E   816A               LDD     R22, Y+2
   \   00000090   01FA               MOVW    R31:R30, R21:R20
   \   00000092   BF6B               OUT     0x3B, R22
   \   00000094   BF07               OUT     0x37, R16
   \   00000096   95E8               SPM
   \   00000098   8108               LD      R16, Y
   \   0000009A   8119               LDD     R17, Y+1
   \   0000009C   812A               LDD     R18, Y+2
   \   0000009E   813B               LDD     R19, Y+3
   \   000000A0   5000               SUBI    R16, 0
   \   000000A2   4F1F               SBCI    R17, 255
   \   000000A4   4F2F               SBCI    R18, 255
   \   000000A6   4F3F               SBCI    R19, 255
   \   000000A8   8308               ST      Y, R16
   \   000000AA   8319               STD     Y+1, R17
   \   000000AC   832A               STD     Y+2, R18
   \   000000AE   833B               STD     Y+3, R19
   \                     ??main_9:
   \   000000B0   8108               LD      R16, Y
   \   000000B2   8119               LDD     R17, Y+1
   \   000000B4   812A               LDD     R18, Y+2
   \   000000B6   813B               LDD     R19, Y+3
   \   000000B8   3000               CPI     R16, 0
   \   000000BA   EF40               LDI     R20, 240
   \   000000BC   0714               CPC     R17, R20
   \   000000BE   E043               LDI     R20, 3
   \   000000C0   0724               CPC     R18, R20
   \   000000C2   E040               LDI     R20, 0
   \   000000C4   0734               CPC     R19, R20
   \   000000C6   F2E4               BRLT    ??main_10
   \                     ??main_5:
   \   000000C8   E00D               LDI     R16, 13
   \   000000CA   CFAF               RJMP    ??main_3
   \                     ??main_8:
   \   000000CC   3602               CPI     R16, 98
   \   000000CE   F441               BRNE    ??main_11
   \   000000D0   E509               LDI     R16, 89
   \   000000D2   ........           CALL    sendchar
   \   000000D6   E001               LDI     R16, 1
   \   000000D8   ........           CALL    sendchar
   \   000000DC   E000               LDI     R16, 0
   \   000000DE   CFA5               RJMP    ??main_3
   \                     ??main_11:
   \   000000E0   3402               CPI     R16, 66
   \   000000E2   F469               BRNE    ??main_12
   \   000000E4   ........           CALL    recchar
   \   000000E8   2F90               MOV     R25, R16
   \   000000EA   ........           CALL    recchar
   \   000000EE   2F80               MOV     R24, R16
   \   000000F0   ........           CALL    recchar
   \   000000F4   01AE               MOVW    R21:R20, R29:R28
   \   000000F6   2F20               MOV     R18, R16
   \   000000F8   018C               MOVW    R17:R16, R25:R24
   \   000000FA   ....               RCALL   BlockLoad
   \   000000FC   CF96               RJMP    ??main_3
   \                     ??main_12:
   \   000000FE   3607               CPI     R16, 103
   \   00000100   F469               BRNE    ??main_13
   \   00000102   ........           CALL    recchar
   \   00000106   2F90               MOV     R25, R16
   \   00000108   ........           CALL    recchar
   \   0000010C   2F80               MOV     R24, R16
   \   0000010E   ........           CALL    recchar
   \   00000112   01AE               MOVW    R21:R20, R29:R28
   \   00000114   2F20               MOV     R18, R16
   \   00000116   018C               MOVW    R17:R16, R25:R24
   \   00000118   ....               RCALL   BlockRead
   \   0000011A   CF89               RJMP    ??main_0
   \                     ??main_13:
   \   0000011C   3502               CPI     R16, 82
   \   0000011E   F5A1               BRNE    ??main_14
   \                     ??main_15:
   \   00000120   B707               IN      R16, 0x37
   \   00000122   2F10               MOV     R17, R16
   \   00000124   FD10               SBRC    R17, 0
   \   00000126   CFFC               RJMP    ??main_15
   \   00000128   E111               LDI     R17, 17
   \   0000012A   2400               CLR     R0
   \   0000012C   BF17               OUT     0x37, R17
   \   0000012E   95E8               SPM
   \   00000130   8108               LD      R16, Y
   \   00000132   8119               LDD     R17, Y+1
   \   00000134   812A               LDD     R18, Y+2
   \   00000136   0F00               LSL     R16
   \   00000138   1F11               ROL     R17
   \   0000013A   1F22               ROL     R18
   \   0000013C   5F0F               SUBI    R16, 255
   \   0000013E   4F1F               SBCI    R17, 255
   \   00000140   4F2F               SBCI    R18, 255
   \   00000142   01F8               MOVW    R31:R30, R17:R16
   \   00000144   BF2B               OUT     0x3B, R18
   \   00000146   9006               ELPM    R0, Z
   \   00000148   E000               LDI     R16, 0
   \   0000014A   BF0B               OUT     0x3B, R16
   \   0000014C   2D00               MOV     R16, R0
   \   0000014E   ........           CALL    sendchar
   \   00000152   8108               LD      R16, Y
   \   00000154   8119               LDD     R17, Y+1
   \   00000156   812A               LDD     R18, Y+2
   \   00000158   0F00               LSL     R16
   \   0000015A   1F11               ROL     R17
   \   0000015C   1F22               ROL     R18
   \   0000015E   01F8               MOVW    R31:R30, R17:R16
   \   00000160   BF2B               OUT     0x3B, R18
   \   00000162   9006               ELPM    R0, Z
   \   00000164   2D00               MOV     R16, R0
   \   00000166   E010               LDI     R17, 0
   \   00000168   BF1B               OUT     0x3B, R17
   \                     ??main_16:
   \   0000016A   ........           CALL    sendchar
   \   0000016E   8108               LD      R16, Y
   \   00000170   8119               LDD     R17, Y+1
   \   00000172   812A               LDD     R18, Y+2
   \   00000174   813B               LDD     R19, Y+3
   \   00000176   5F0F               SUBI    R16, 255
   \   00000178   4F1F               SBCI    R17, 255
   \   0000017A   4F2F               SBCI    R18, 255
   \   0000017C   4F3F               SBCI    R19, 255
   \   0000017E   8308               ST      Y, R16
   \   00000180   8319               STD     Y+1, R17
   \   00000182   832A               STD     Y+2, R18
   \   00000184   833B               STD     Y+3, R19
   \   00000186   CF53               RJMP    ??main_0
   \                     ??main_14:
   \   00000188   3603               CPI     R16, 99
   \   0000018A   F429               BRNE    ??main_17
   \   0000018C   ........           CALL    recchar
   \   00000190   2F80               MOV     R24, R16
   \   00000192   E090               LDI     R25, 0
   \   00000194   CF99               RJMP    ??main_5
   \                     ??main_17:
   \   00000196   3403               CPI     R16, 67
   \   00000198   F4A1               BRNE    ??main_18
   \   0000019A   ........           CALL    recchar
   \   0000019E   2B90               OR      R25, R16
   \                     ??main_19:
   \   000001A0   B707               IN      R16, 0x37
   \   000001A2   2F10               MOV     R17, R16
   \   000001A4   FD10               SBRC    R17, 0
   \   000001A6   CFFC               RJMP    ??main_19
   \   000001A8   E001               LDI     R16, 1
   \   000001AA   8148               LD      R20, Y
   \   000001AC   8159               LDD     R21, Y+1
   \   000001AE   816A               LDD     R22, Y+2
   \   000001B0   0F44               LSL     R20
   \   000001B2   1F55               ROL     R21
   \   000001B4   1F66               ROL     R22
   \   000001B6   01FA               MOVW    R31:R30, R21:R20
   \   000001B8   BF6B               OUT     0x3B, R22
   \   000001BA   010C               MOVW    R1:R0, R25:R24
   \   000001BC   BF07               OUT     0x37, R16
   \   000001BE   95E8               SPM
   \   000001C0   C033               RJMP    ??main_20
   \                     ??main_18:
   \   000001C2   360D               CPI     R16, 109
   \   000001C4   F501               BRNE    ??main_21
   \   000001C6   8108               LD      R16, Y
   \   000001C8   8119               LDD     R17, Y+1
   \   000001CA   812A               LDD     R18, Y+2
   \   000001CC   813B               LDD     R19, Y+3
   \   000001CE   3000               CPI     R16, 0
   \   000001D0   EF48               LDI     R20, 248
   \   000001D2   0714               CPC     R17, R20
   \   000001D4   E041               LDI     R20, 1
   \   000001D6   0724               CPC     R18, R20
   \   000001D8   E040               LDI     R20, 0
   \   000001DA   0734               CPC     R19, R20
   \   000001DC   F024               BRLT    ??main_22
   \   000001DE   E30F               LDI     R16, 63
   \   000001E0   ........           CALL    sendchar
   \   000001E4   CF71               RJMP    ??main_5
   \                     ??main_22:
   \   000001E6   B707               IN      R16, 0x37
   \   000001E8   2F10               MOV     R17, R16
   \   000001EA   FD10               SBRC    R17, 0
   \   000001EC   CFFC               RJMP    ??main_22
   \   000001EE   E005               LDI     R16, 5
   \   000001F0   8148               LD      R20, Y
   \   000001F2   8159               LDD     R21, Y+1
   \   000001F4   816A               LDD     R22, Y+2
   \   000001F6   0F44               LSL     R20
   \   000001F8   1F55               ROL     R21
   \   000001FA   1F66               ROL     R22
   \   000001FC   01FA               MOVW    R31:R30, R21:R20
   \   000001FE   BF6B               OUT     0x3B, R22
   \                     ??main_23:
   \   00000200   BF07               OUT     0x37, R16
   \   00000202   95E8               SPM
   \   00000204   CF61               RJMP    ??main_5
   \                     ??main_21:
   \   00000206   3404               CPI     R16, 68
   \   00000208   F4D9               BRNE    ??main_24
   \                     ??main_25:
   \   0000020A   B707               IN      R16, 0x37
   \   0000020C   2F10               MOV     R17, R16
   \   0000020E   FD10               SBRC    R17, 0
   \   00000210   CFFC               RJMP    ??main_25
   \   00000212   8108               LD      R16, Y
   \   00000214   BD01               OUT     0x21, R16
   \   00000216   8119               LDD     R17, Y+1
   \   00000218   BD12               OUT     0x22, R17
   \   0000021A   ........           CALL    recchar
   \   0000021E   BD00               OUT     0x20, R16
   \   00000220   9AFA               SBI     0x1F, 0x02
   \   00000222   9AF9               SBI     0x1F, 0x01
   \                     ??main_26:
   \   00000224   99F9               SBIC    0x1F, 0x01
   \   00000226   CFFE               RJMP    ??main_26
   \                     ??main_20:
   \   00000228   8108               LD      R16, Y
   \   0000022A   8119               LDD     R17, Y+1
   \   0000022C   812A               LDD     R18, Y+2
   \   0000022E   813B               LDD     R19, Y+3
   \   00000230   5F0F               SUBI    R16, 255
   \   00000232   4F1F               SBCI    R17, 255
   \   00000234   4F2F               SBCI    R18, 255
   \   00000236   4F3F               SBCI    R19, 255
   \   00000238   8308               ST      Y, R16
   \   0000023A   8319               STD     Y+1, R17
   \   0000023C   832A               STD     Y+2, R18
   \   0000023E   CF16               RJMP    ??main_7
   \                     ??main_24:
   \   00000240   3604               CPI     R16, 100
   \   00000242   F439               BRNE    ??main_27
   \   00000244   8108               LD      R16, Y
   \   00000246   BD01               OUT     0x21, R16
   \   00000248   8119               LDD     R17, Y+1
   \   0000024A   BD12               OUT     0x22, R17
   \   0000024C   9AF8               SBI     0x1F, 0x00
   \   0000024E   B500               IN      R16, 0x20
   \   00000250   CF8C               RJMP    ??main_16
   \                     ??main_27:
   \   00000252   360C               CPI     R16, 108
   \   00000254   F451               BRNE    ??main_28
   \                     ??main_29:
   \   00000256   B707               IN      R16, 0x37
   \   00000258   2F10               MOV     R17, R16
   \   0000025A   FD10               SBRC    R17, 0
   \   0000025C   CFFC               RJMP    ??main_29
   \   0000025E   ........           CALL    recchar
   \   00000262   2F10               MOV     R17, R16
   \   00000264   E009               LDI     R16, 9
   \   00000266   2E01               MOV     R0, R17
   \   00000268   CFCB               RJMP    ??main_23
   \                     ??main_28:
   \   0000026A   3702               CPI     R16, 114
   \   0000026C   F459               BRNE    ??main_30
   \                     ??main_31:
   \   0000026E   B707               IN      R16, 0x37
   \   00000270   2F10               MOV     R17, R16
   \   00000272   FD10               SBRC    R17, 0
   \   00000274   CFFC               RJMP    ??main_31
   \   00000276   E009               LDI     R16, 9
   \   00000278   E0E1               LDI     R30, 1
   \                     ??main_32:
   \   0000027A   E0F0               LDI     R31, 0
   \   0000027C   BF07               OUT     0x37, R16
   \   0000027E   9114               LPM     R17, Z
   \   00000280   2F01               MOV     R16, R17
   \   00000282   CED3               RJMP    ??main_3
   \                     ??main_30:
   \   00000284   3406               CPI     R16, 70
   \   00000286   F439               BRNE    ??main_33
   \                     ??main_34:
   \   00000288   B707               IN      R16, 0x37
   \   0000028A   2F10               MOV     R17, R16
   \   0000028C   FD10               SBRC    R17, 0
   \   0000028E   CFFC               RJMP    ??main_34
   \   00000290   E009               LDI     R16, 9
   \   00000292   E0E0               LDI     R30, 0
   \   00000294   CFF2               RJMP    ??main_32
   \                     ??main_33:
   \   00000296   340E               CPI     R16, 78
   \   00000298   F439               BRNE    ??main_35
   \                     ??main_36:
   \   0000029A   B707               IN      R16, 0x37
   \   0000029C   2F10               MOV     R17, R16
   \   0000029E   FD10               SBRC    R17, 0
   \   000002A0   CFFC               RJMP    ??main_36
   \   000002A2   E009               LDI     R16, 9
   \   000002A4   E0E3               LDI     R30, 3
   \   000002A6   CFE9               RJMP    ??main_32
   \                     ??main_35:
   \   000002A8   3501               CPI     R16, 81
   \   000002AA   F439               BRNE    ??main_37
   \                     ??main_38:
   \   000002AC   B707               IN      R16, 0x37
   \   000002AE   2F10               MOV     R17, R16
   \   000002B0   FD10               SBRC    R17, 0
   \   000002B2   CFFC               RJMP    ??main_38
   \   000002B4   E009               LDI     R16, 9
   \   000002B6   E0E2               LDI     R30, 2
   \   000002B8   CFE0               RJMP    ??main_32
   \                     ??main_37:
   \   000002BA   3503               CPI     R16, 83
   \   000002BC   F4A1               BRNE    ??main_39
   \   000002BE   E401               LDI     R16, 65
   \   000002C0   ........           CALL    sendchar
   \   000002C4   E506               LDI     R16, 86
   \   000002C6   ........           CALL    sendchar
   \   000002CA   E502               LDI     R16, 82
   \   000002CC   ........           CALL    sendchar
   \   000002D0   E402               LDI     R16, 66
   \   000002D2   ........           CALL    sendchar
   \   000002D6   E40F               LDI     R16, 79
   \   000002D8   ........           CALL    sendchar
   \   000002DC   E40F               LDI     R16, 79
   \   000002DE   ........           CALL    sendchar
   \   000002E2   E504               LDI     R16, 84
   \   000002E4   CEA2               RJMP    ??main_3
   \                     ??main_39:
   \   000002E6   3506               CPI     R16, 86
   \   000002E8   F429               BRNE    ??main_40
   \   000002EA   E301               LDI     R16, 49
   \   000002EC   ........           CALL    sendchar
   \   000002F0   E305               LDI     R16, 53
   \   000002F2   CE9B               RJMP    ??main_3
   \                     ??main_40:
   \   000002F4   3703               CPI     R16, 115
   \   000002F6   F441               BRNE    ??main_41
   \   000002F8   E001               LDI     R16, 1
   \   000002FA   ........           CALL    sendchar
   \   000002FE   E908               LDI     R16, 152
   \   00000300   ........           CALL    sendchar
   \   00000304   E10E               LDI     R16, 30
   \   00000306   CE91               RJMP    ??main_3
   \                     ??main_41:
   \   00000308   310B               CPI     R16, 27
   \   0000030A   F409               BRNE    $+2+2
   \   0000030C   CE90               RJMP    ??main_0
   \   0000030E   E30F               LDI     R16, 63
   \   00000310   CE8C               RJMP    ??main_3
    364          
    365          
    366          #ifndef REMOVE_BLOCK_SUPPORT
    367          /*! \brief  Write block from serial port and program mem.
    368           *
    369           *  Read 'size' bytes from serial port and write to EPROM/Flash
    370           *  memory 'address'.
    371           *  If 'mem' == 'E', then 'address' gives
    372           *  the byte address in EEPROM. If 'mem' == 'F', then 'address'
    373           *  gives the word address in Flash.
    374           */

   \                                 In segment FARCODE, align 2, keep-with-next
    375          unsigned char BlockLoad(unsigned int size, unsigned char mem, long *address)
   \                     BlockLoad:
    376          {
   \   00000000   ........           CALL    ?PROLOGUE10_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004   50D1               SUBI    R29, 1
   \   00000006   0138               MOVW    R7:R6, R17:R16
   \   00000008   012A               MOVW    R5:R4, R21:R20
    377          	unsigned char buffer[BLOCKSIZE];
    378          	unsigned int data;
    379          	long tempaddress;
    380          
    381          	// EEPROM memory type.
    382          	if(mem=='E')
   \   0000000A   3425               CPI     R18, 69
   \   0000000C   F009               BREQ    $+2+2
   \   0000000E   C046               RJMP    ??BlockLoad_0
    383          	{
    384          		/* Fill buffer first, as EEPROM is too slow to copy with UART speed */
    385          		for(tempaddress=0;tempaddress<size;tempaddress++)
   \   00000010   E080               LDI     R24, 0
   \   00000012   E090               LDI     R25, 0
   \   00000014   E0A0               LDI     R26, 0
   \   00000016   E0B0               LDI     R27, 0
   \   00000018   C00B               RJMP    ??BlockLoad_1
    386          			buffer[tempaddress] = recchar();
   \                     ??BlockLoad_2:
   \   0000001A   ........           CALL    recchar
   \   0000001E   01FE               MOVW    R31:R30, R29:R28
   \   00000020   019C               MOVW    R19:R18, R25:R24
   \   00000022   0FE2               ADD     R30, R18
   \   00000024   1FF3               ADC     R31, R19
   \   00000026   8300               ST      Z, R16
   \   00000028   5F8F               SUBI    R24, 255
   \   0000002A   4F9F               SBCI    R25, 255
   \   0000002C   4FAF               SBCI    R26, 255
   \   0000002E   4FBF               SBCI    R27, 255
   \                     ??BlockLoad_1:
   \   00000030   E060               LDI     R22, 0
   \   00000032   1586               CP      R24, R6
   \   00000034   0597               CPC     R25, R7
   \   00000036   07A6               CPC     R26, R22
   \   00000038   07B6               CPC     R27, R22
   \   0000003A   F37C               BRLT    ??BlockLoad_2
    387          
    388          		/* Then program the EEPROM */
    389          		_WAIT_FOR_SPM();
   \                     ??BlockLoad_3:
   \   0000003C   B707               IN      R16, 0x37
   \   0000003E   2F10               MOV     R17, R16
   \   00000040   FD10               SBRC    R17, 0
   \   00000042   CFFC               RJMP    ??BlockLoad_3
    390          		for( tempaddress=0; tempaddress < size; tempaddress++)
   \   00000044   E080               LDI     R24, 0
   \   00000046   E090               LDI     R25, 0
   \   00000048   E0A0               LDI     R26, 0
   \   0000004A   E0B0               LDI     R27, 0
   \   0000004C   C020               RJMP    ??BlockLoad_4
    391          		{
    392          			EEARL = *address; // Setup EEPROM address
   \                     ??BlockLoad_5:
   \   0000004E   01F2               MOVW    R31:R30, R5:R4
   \   00000050   8100               LD      R16, Z
   \   00000052   BD01               OUT     0x21, R16
    393          			EEARH = ((*address) >> 8);
   \   00000054   8111               LDD     R17, Z+1
   \   00000056   BD12               OUT     0x22, R17
    394          			EEDR = buffer[tempaddress]; // Get byte.
   \   00000058   01FE               MOVW    R31:R30, R29:R28
   \   0000005A   018C               MOVW    R17:R16, R25:R24
   \   0000005C   0FE0               ADD     R30, R16
   \   0000005E   1FF1               ADC     R31, R17
   \   00000060   8100               LD      R16, Z
   \   00000062   BD00               OUT     0x20, R16
    395          			EECR |= (1<<EEMWE); // Write byte.
   \   00000064   9AFA               SBI     0x1F, 0x02
    396          			EECR |= (1<<EEWE);
   \   00000066   9AF9               SBI     0x1F, 0x01
    397          			while (EECR & (1<<EEWE)) // Wait for write operation to finish.
   \                     ??BlockLoad_6:
   \   00000068   99F9               SBIC    0x1F, 0x01
   \   0000006A   CFFE               RJMP    ??BlockLoad_6
    398          				;
    399          
    400          			(*address)++; // Select next EEPROM byte
   \   0000006C   01F2               MOVW    R31:R30, R5:R4
   \   0000006E   8100               LD      R16, Z
   \   00000070   8111               LDD     R17, Z+1
   \   00000072   8122               LDD     R18, Z+2
   \   00000074   8133               LDD     R19, Z+3
   \   00000076   5F0F               SUBI    R16, 255
   \   00000078   4F1F               SBCI    R17, 255
   \   0000007A   4F2F               SBCI    R18, 255
   \   0000007C   4F3F               SBCI    R19, 255
   \   0000007E   8300               ST      Z, R16
   \   00000080   8311               STD     Z+1, R17
   \   00000082   8322               STD     Z+2, R18
   \   00000084   8333               STD     Z+3, R19
    401          		}
   \   00000086   5F8F               SUBI    R24, 255
   \   00000088   4F9F               SBCI    R25, 255
   \   0000008A   4FAF               SBCI    R26, 255
   \   0000008C   4FBF               SBCI    R27, 255
   \                     ??BlockLoad_4:
   \   0000008E   1586               CP      R24, R6
   \   00000090   0597               CPC     R25, R7
   \   00000092   07A6               CPC     R26, R22
   \   00000094   07B6               CPC     R27, R22
   \   00000096   F2DC               BRLT    ??BlockLoad_5
    402          
    403          		return '\r'; // Report programming OK
   \                     ??BlockLoad_7:
   \   00000098   E00D               LDI     R16, 13
   \   0000009A   C05D               RJMP    ??BlockLoad_8
    404          	}
    405          
    406          	// Flash memory type.
    407          	else if(mem=='F')
   \                     ??BlockLoad_0:
   \   0000009C   3426               CPI     R18, 70
   \   0000009E   F009               BREQ    $+2+2
   \   000000A0   C059               RJMP    ??BlockLoad_9
    408          	{ // NOTE: For flash programming, 'address' is given in words.
    409          		(*address) <<= 1; // Convert address to bytes temporarily.
   \   000000A2   01F2               MOVW    R31:R30, R5:R4
   \   000000A4   8100               LD      R16, Z
   \   000000A6   8111               LDD     R17, Z+1
   \   000000A8   8122               LDD     R18, Z+2
   \   000000AA   8133               LDD     R19, Z+3
   \   000000AC   0F00               LSL     R16
   \   000000AE   1F11               ROL     R17
   \   000000B0   1F22               ROL     R18
   \   000000B2   1F33               ROL     R19
   \   000000B4   8300               ST      Z, R16
   \   000000B6   8311               STD     Z+1, R17
   \   000000B8   8322               STD     Z+2, R18
   \   000000BA   8333               STD     Z+3, R19
    410          		tempaddress = (*address);  // Store address in page.
   \   000000BC   8180               LD      R24, Z
   \   000000BE   8191               LDD     R25, Z+1
   \   000000C0   81A2               LDD     R26, Z+2
   \   000000C2   81B3               LDD     R27, Z+3
    411          
    412          		do
    413          		{
    414          			data = recchar();
   \                     ??BlockLoad_10:
   \   000000C4   ........           CALL    recchar
   \   000000C8   2E80               MOV     R8, R16
   \   000000CA   2499               CLR     R9
    415          			data |= (recchar() << 8);
   \   000000CC   ........           CALL    recchar
   \   000000D0   2A90               OR      R9, R16
    416          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    417          			_FILL_TEMP_WORD(*address,data);
   \   000000D2   E001               LDI     R16, 1
   \   000000D4   01F2               MOVW    R31:R30, R5:R4
   \   000000D6   8140               LD      R20, Z
   \   000000D8   8151               LDD     R21, Z+1
   \   000000DA   8162               LDD     R22, Z+2
   \   000000DC   01FA               MOVW    R31:R30, R21:R20
   \   000000DE   BF6B               OUT     0x3B, R22
   \   000000E0   0104               MOVW    R1:R0, R9:R8
   \   000000E2   BF07               OUT     0x37, R16
   \   000000E4   95E8               SPM
    418          #pragma diag_default=Pe1053 // Back to default.
    419          			(*address)+=2; // Select next word in memory.
   \   000000E6   01F2               MOVW    R31:R30, R5:R4
   \   000000E8   8100               LD      R16, Z
   \   000000EA   8111               LDD     R17, Z+1
   \   000000EC   8122               LDD     R18, Z+2
   \   000000EE   8133               LDD     R19, Z+3
   \   000000F0   5F0E               SUBI    R16, 254
   \   000000F2   4F1F               SBCI    R17, 255
   \   000000F4   4F2F               SBCI    R18, 255
   \   000000F6   4F3F               SBCI    R19, 255
   \   000000F8   8300               ST      Z, R16
   \   000000FA   8311               STD     Z+1, R17
   \   000000FC   8322               STD     Z+2, R18
   \   000000FE   8333               STD     Z+3, R19
    420          			size -= 2; // Reduce number of bytes to write by two.
   \   00000100   EF0E               LDI     R16, 254
   \   00000102   0E60               ADD     R6, R16
   \   00000104   EF0F               LDI     R16, 255
   \   00000106   1E70               ADC     R7, R16
    421          		} while(size); // Loop until all bytes written.
   \   00000108   2D06               MOV     R16, R6
   \   0000010A   2907               OR      R16, R7
   \   0000010C   F6D9               BRNE    ??BlockLoad_10
    422          
    423          		if( tempaddress < (APP_END) ) { // Protect bootloader area.
   \   0000010E   3080               CPI     R24, 0
   \   00000110   EF00               LDI     R16, 240
   \   00000112   0790               CPC     R25, R16
   \   00000114   E003               LDI     R16, 3
   \   00000116   07A0               CPC     R26, R16
   \   00000118   E000               LDI     R16, 0
   \   0000011A   07B0               CPC     R27, R16
   \   0000011C   F44C               BRGE    ??BlockLoad_11
    424          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    425          			_PAGE_WRITE(tempaddress);
   \   0000011E   E005               LDI     R16, 5
   \   00000120   01FC               MOVW    R31:R30, R25:R24
   \   00000122   BFAB               OUT     0x3B, R26
   \   00000124   BF07               OUT     0x37, R16
   \   00000126   95E8               SPM
    426          #pragma diag_default=Pe1053 // Back to default.
    427          			_WAIT_FOR_SPM();
   \                     ??BlockLoad_12:
   \   00000128   B707               IN      R16, 0x37
   \   0000012A   2F10               MOV     R17, R16
   \   0000012C   FD10               SBRC    R17, 0
   \   0000012E   CFFC               RJMP    ??BlockLoad_12
    428          		}
    429          		_ENABLE_RWW_SECTION();
   \                     ??BlockLoad_11:
   \   00000130   E111               LDI     R17, 17
   \   00000132   2400               CLR     R0
   \   00000134   BF17               OUT     0x37, R17
   \   00000136   95E8               SPM
    430          
    431          		(*address) >>= 1; // Convert address back to Flash words again.
   \   00000138   01F2               MOVW    R31:R30, R5:R4
   \   0000013A   8100               LD      R16, Z
   \   0000013C   8111               LDD     R17, Z+1
   \   0000013E   8122               LDD     R18, Z+2
   \   00000140   8133               LDD     R19, Z+3
   \   00000142   9535               ASR     R19
   \   00000144   9527               ROR     R18
   \   00000146   9517               ROR     R17
   \   00000148   9507               ROR     R16
   \   0000014A   8300               ST      Z, R16
   \   0000014C   8311               STD     Z+1, R17
   \   0000014E   8322               STD     Z+2, R18
   \   00000150   8333               STD     Z+3, R19
   \   00000152   CFA2               RJMP    ??BlockLoad_7
    432          		return '\r'; // Report programming OK
    433          	}
    434          
    435          	// Invalid memory type?
    436          	else
    437          	{
    438          		return '?';
   \                     ??BlockLoad_9:
   \   00000154   E30F               LDI     R16, 63
   \                     ??BlockLoad_8:
   \   00000156   5FDF               SUBI    R29, 255
   \   00000158   E0EA               LDI     R30, 10
   \   0000015A   ........           JMP     ?EPILOGUE_B10_L09
    439          	}
    440          }
    441          
    442          
    443          
    444          /*! \brief  Read block of mem and send to serial port.
    445           *
    446           *  Read 'size' bytes from EEPROM/Flash memory 'address' and
    447           *  send to serial port. If 'mem' == 'E', then 'address' gives
    448           *  the byte address in EEPROM. If 'mem' == 'F', then 'address'
    449           *  gives the word address in Flash.
    450           */

   \                                 In segment FARCODE, align 2, keep-with-next
    451          void BlockRead(unsigned int size, unsigned char mem, long *address)
   \                     BlockRead:
    452          {
   \   00000000   ........           CALL    ?PROLOGUE4_L09
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   01DA               MOVW    R27:R26, R21:R20
    453          	// EEPROM memory type.
    454          	if (mem=='E') // Read EEPROM
   \   00000008   3425               CPI     R18, 69
   \   0000000A   F501               BRNE    ??BlockRead_0
    455          	{
    456          		do
    457          		{
    458          			EEARL = *address; // Setup EEPROM address
   \                     ??BlockRead_1:
   \   0000000C   910D               LD      R16, X+
   \   0000000E   911D               LD      R17, X+
   \   00000010   912D               LD      R18, X+
   \   00000012   9713               SBIW    R27:R26, 3
   \   00000014   BD01               OUT     0x21, R16
    459          			EEARH = ((*address) >> 8);
   \   00000016   910D               LD      R16, X+
   \   00000018   911D               LD      R17, X+
   \   0000001A   912D               LD      R18, X+
   \   0000001C   9713               SBIW    R27:R26, 3
   \   0000001E   BD12               OUT     0x22, R17
    460          			(*address)++; // Select next EEPROM byte
   \   00000020   01FD               MOVW    R31:R30, R27:R26
   \   00000022   8100               LD      R16, Z
   \   00000024   8111               LDD     R17, Z+1
   \   00000026   8122               LDD     R18, Z+2
   \   00000028   8133               LDD     R19, Z+3
   \   0000002A   5F0F               SUBI    R16, 255
   \   0000002C   4F1F               SBCI    R17, 255
   \   0000002E   4F2F               SBCI    R18, 255
   \   00000030   4F3F               SBCI    R19, 255
   \   00000032   8300               ST      Z, R16
   \   00000034   8311               STD     Z+1, R17
   \   00000036   8322               STD     Z+2, R18
   \   00000038   8333               STD     Z+3, R19
    461          			EECR |= (1<<EERE); // Read EEPROM
   \   0000003A   9AF8               SBI     0x1F, 0x00
    462          			sendchar(EEDR); // Transmit EEPROM dat ato PC
   \   0000003C   B500               IN      R16, 0x20
   \   0000003E   ........           CALL    sendchar
    463          
    464          			size--; // Decrease number of bytes to read
   \   00000042   9701               SBIW    R25:R24, 1
    465          		} while (size); // Repeat until all block has been read
   \   00000044   2F08               MOV     R16, R24
   \   00000046   2B09               OR      R16, R25
   \   00000048   F709               BRNE    ??BlockRead_1
   \   0000004A   C049               RJMP    ??BlockRead_2
    466          	}
    467          
    468          	// Flash memory type.
    469          	else if(mem=='F')
   \                     ??BlockRead_0:
   \   0000004C   3426               CPI     R18, 70
   \   0000004E   F009               BREQ    $+2+2
   \   00000050   C046               RJMP    ??BlockRead_2
    470          	{
    471          		(*address) <<= 1; // Convert address to bytes temporarily.
   \   00000052   910D               LD      R16, X+
   \   00000054   911D               LD      R17, X+
   \   00000056   912D               LD      R18, X+
   \   00000058   913C               LD      R19, X
   \   0000005A   9713               SBIW    R27:R26, 3
   \   0000005C   0F00               LSL     R16
   \   0000005E   1F11               ROL     R17
   \   00000060   1F22               ROL     R18
   \   00000062   1F33               ROL     R19
   \   00000064   930D               ST      X+, R16
   \   00000066   931D               ST      X+, R17
   \   00000068   932D               ST      X+, R18
   \   0000006A   933C               ST      X, R19
   \   0000006C   9713               SBIW    R27:R26, 3
    472          
    473          		do
    474          		{
    475          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    476          			sendchar( _LOAD_PROGRAM_MEMORY(*address) );
   \                     ??BlockRead_3:
   \   0000006E   910D               LD      R16, X+
   \   00000070   911D               LD      R17, X+
   \   00000072   912D               LD      R18, X+
   \   00000074   9713               SBIW    R27:R26, 3
   \   00000076   01F8               MOVW    R31:R30, R17:R16
   \   00000078   BF2B               OUT     0x3B, R18
   \   0000007A   9006               ELPM    R0, Z
   \   0000007C   2D00               MOV     R16, R0
   \   0000007E   E010               LDI     R17, 0
   \   00000080   BF1B               OUT     0x3B, R17
   \   00000082   ........           CALL    sendchar
    477          			sendchar( _LOAD_PROGRAM_MEMORY((*address)+1) );
   \   00000086   910D               LD      R16, X+
   \   00000088   911D               LD      R17, X+
   \   0000008A   912D               LD      R18, X+
   \   0000008C   9713               SBIW    R27:R26, 3
   \   0000008E   5F0F               SUBI    R16, 255
   \   00000090   4F1F               SBCI    R17, 255
   \   00000092   4F2F               SBCI    R18, 255
   \   00000094   01F8               MOVW    R31:R30, R17:R16
   \   00000096   BF2B               OUT     0x3B, R18
   \   00000098   9006               ELPM    R0, Z
   \   0000009A   E000               LDI     R16, 0
   \   0000009C   BF0B               OUT     0x3B, R16
   \   0000009E   2D00               MOV     R16, R0
   \   000000A0   ........           CALL    sendchar
    478          #pragma diag_default=Pe1053 // Back to default.
    479          			(*address) += 2; // Select next word in memory.
   \   000000A4   910D               LD      R16, X+
   \   000000A6   911D               LD      R17, X+
   \   000000A8   912D               LD      R18, X+
   \   000000AA   913C               LD      R19, X
   \   000000AC   5F0E               SUBI    R16, 254
   \   000000AE   4F1F               SBCI    R17, 255
   \   000000B0   4F2F               SBCI    R18, 255
   \   000000B2   4F3F               SBCI    R19, 255
   \   000000B4   933C               ST      X, R19
   \   000000B6   932E               ST      -X, R18
   \   000000B8   931E               ST      -X, R17
   \   000000BA   930E               ST      -X, R16
    480          			size -= 2; // Subtract two bytes from number of bytes to read
   \   000000BC   9702               SBIW    R25:R24, 2
    481          		} while (size); // Repeat until all block has been read
   \   000000BE   2F08               MOV     R16, R24
   \   000000C0   2B09               OR      R16, R25
   \   000000C2   F6A9               BRNE    ??BlockRead_3
    482          
    483          		(*address) >>= 1; // Convert address back to Flash words again.
   \   000000C4   910D               LD      R16, X+
   \   000000C6   911D               LD      R17, X+
   \   000000C8   912D               LD      R18, X+
   \   000000CA   913C               LD      R19, X
   \   000000CC   9713               SBIW    R27:R26, 3
   \   000000CE   9535               ASR     R19
   \   000000D0   9527               ROR     R18
   \   000000D2   9517               ROR     R17
   \   000000D4   9507               ROR     R16
   \   000000D6   930D               ST      X+, R16
   \   000000D8   931D               ST      X+, R17
   \   000000DA   932D               ST      X+, R18
   \   000000DC   933C               ST      X, R19
    484          	}
    485          }
   \                     ??BlockRead_2:
   \   000000DE   E0E4               LDI     R30, 4
   \   000000E0   ........           JMP     ?EPILOGUE_B4_L09
    486          #endif
    487          
    488          
    489          /* end of file */
    490          

   Maximum stack usage in bytes:

     Function             CSTACK RSTACK
     --------             ------ ------
     BlockLoad              266      3
       -> recchar           266      3
       -> recchar           266      3
       -> recchar           266      3
     BlockRead                4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
     main                     4      3
       -> initbootuart        4      3
       ->   Indirect call     4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> BlockLoad           4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> BlockRead           4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     _A_SPMCSR         1
     _A_EEAR           2
     _A_EEDR           1
     _A_EECR           1
     _A_PORTD          1
     _A_PIND           1
     main            786
     BlockLoad       350
     BlockRead       228

 
     7 bytes in segment ABSOLUTE
 1 364 bytes in segment FARCODE
 
 1 364 bytes of CODE memory
     0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
