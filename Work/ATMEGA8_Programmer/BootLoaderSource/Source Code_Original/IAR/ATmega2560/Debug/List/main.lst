##############################################################################
#                                                                            #
# IAR Atmel AVR C/C++ Compiler V4.11A/W32              17/Jan/2006  19:30:54 #
# Copyright 1996-2005 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Source file  =  C:\Documents and Settings\andeaper\My                   #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\main.c                              #
#    Command line =  "C:\Documents and Settings\andeaper\My                  #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\main.c" --cpu=m2560 -ms -o          #
#                    "C:\Documents and Settings\andeaper\My                  #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\Debug\Obj\" -lCN "C:\Documents and  #
#                    Settings\andeaper\My Documents\QVCS\Appnotes\AVR109     #
#                    Self Programming\Source Code\IAR\ATmega2560\Debug\List\ #
#                    " -y --initializers_in_flash -z2 --no_cse --no_inline   #
#                    --no_code_motion --no_cross_call --no_clustering        #
#                    --no_tbaa --cross_call_passes=4 --debug                 #
#                    -DENABLE_BIT_DEFINITIONS --do_cross_call -e -I          #
#                    "C:\Program Files\IAR Systems\Embedded Workbench        #
#                    4.0\avr\INC\" -I "C:\Program Files\IAR                  #
#                    Systems\Embedded Workbench 4.0\avr\INC\CLIB\"           #
#                    --eeprom_size 4096                                      #
#    List file    =  C:\Documents and Settings\andeaper\My                   #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\Debug\List\main.lst                 #
#    Object file  =  C:\Documents and Settings\andeaper\My                   #
#                    Documents\QVCS\Appnotes\AVR109 Self Programming\Source  #
#                    Code\IAR\ATmega2560\Debug\Obj\main.r90                  #
#                                                                            #
#                                                                            #
##############################################################################

C:\Documents and Settings\andeaper\My Documents\QVCS\Appnotes\AVR109 Self Programming\Source Code\IAR\ATmega2560\main.c
      1          /*****************************************************************************
      2          *
      3          * Atmel Corporation
      4          *
      5          * File              : main.c
      6          * Compiler          : IAR C 3.10C Kickstart
      7          * Revision          : $Revision: 2.0 $
      8          * Date              : $Date: Tuesday, November 29, $
      9          * Updated by        : $Author: raapeland $
     10          *
     11          * Support mail      : avr@atmel.com
     12          *
     13          * Target platform   : All AVRs with bootloader support
     14          *
     15          * AppNote           : AVR109 - Self-programming
     16          *
     17          * Description   : This Program allows an AVR with bootloader capabilities to
     18          *                 Read/write its own Flash/EEprom. To enter Programming mode
     19          *                 an input pin is checked. If this pin is pulled low, programming mode
     20          *                 is entered. If not, normal execution is done from $0000
     21          *                 "reset" vector in Application area.
     22          *
     23          * Preparations  : Use the preprocessor.xls file for obtaining a customized
     24          *                 defines.h file and linker-file code-segment definition for
     25          *                 the device you are compiling for.
     26          ****************************************************************************/
     27          #include <inavr.h>
     28          #include "defines.h"

   \                                 In segment ABSOLUTE, at 0x57
   \   union <unnamed> volatile __io _A_SPMCSR
   \                     _A_SPMCSR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x41
   \   union <unnamed> volatile __io _A_EEAR
   \                     _A_EEAR:
   \   00000000                      DS 2

   \                                 In segment ABSOLUTE, at 0x40
   \   union <unnamed> volatile __io _A_EEDR
   \                     _A_EEDR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x3f
   \   union <unnamed> volatile __io _A_EECR
   \                     _A_EECR:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x2b
   \   union <unnamed> volatile __io _A_PORTD
   \                     _A_PORTD:
   \   00000000                      DS 1

   \                                 In segment ABSOLUTE, at 0x29
   \   union <unnamed> volatile __io _A_PIND
   \                     _A_PIND:
   \   00000000                      DS 1
     29          #include "serial.h"
     30          #include "flash.h"
     31          
     32          
     33          #ifndef EEWE
     34            #define EEWE EEPE
     35          #endif
     36          #ifndef EEMWE
     37            #define EEMWE EEMPE
     38          #endif
     39          
     40          /*** WARNING: The AVRprog application in AVR Studio does not support block mode,
     41               but it will try to use it anyway. Therefore, block mode must be disabled below
     42               if AVRprog is going to be used. ***/
     43          
     44          
     45          /* Uncomment the following to save code space */
     46          #define REMOVE_AVRPROG_SUPPORT
     47          //#define REMOVE_FUSE_AND_LOCK_BIT_SUPPORT
     48          //#define REMOVE_BLOCK_SUPPORT
     49          //#define REMOVE_EEPROM_BYTE_SUPPORT
     50          //#define REMOVE_FLASH_BYTE_SUPPORT
     51          
     52          
     53          
     54          #ifndef REMOVE_BLOCK_SUPPORT
     55          unsigned char BlockLoad(unsigned int size, unsigned char mem, long *address);
     56          void BlockRead(unsigned int size, unsigned char mem, long *address);
     57          
     58          /* BLOCKSIZE should be chosen so that the following holds: BLOCKSIZE*n = PAGESIZE,  where n=1,2,3... */
     59          #define BLOCKSIZE PAGESIZE
     60          
     61          #endif
     62          
     63          
     64          

   \                                 In segment FARCODE, align 2, keep-with-next
     65          __C_task void main(void)
   \                     main:
     66          {
   \   00000000   9724               SBIW    R29:R28, 4
     67          	long address;
     68          	unsigned int temp_int;
     69          	unsigned char val;
     70          
     71          
     72          	/* Initialization */
     73          	void (*funcptr)( void ) = 0x0000; // Set up function pointer to RESET vector.
   \   00000002   E000               LDI     R16, 0
   \   00000004   E010               LDI     R17, 0
   \   00000006   E020               LDI     R18, 0
   \   00000008   0128               MOVW    R5:R4, R17:R16
   \   0000000A   2E62               MOV     R6, R18
     74          	PROGPORT |= (1<<PROG_NO); // Enable pull-up on PROG_NO line on PROGPORT.
   \   0000000C   9A5C               SBI     0x0B, 0x04
     75          	initbootuart(); // Initialize UART.
   \   0000000E   ........           CALL    initbootuart
     76          
     77          	/* Branch to bootloader or application code? */
     78          	if( !(PROGPIN & (1<<PROG_NO)) ) // If PROGPIN is pulled low, enter programmingmode.
   \   00000012   994C               SBIC    0x09, 0x04
   \   00000014   C1E5               RJMP    ??main_0
     79          	{
     80          		/* Main loop */
     81          		for(;;)
     82          		{
     83          			val=recchar(); // Wait for command character.
   \                     ??main_1:
   \   00000016   ........           CALL    recchar
   \   0000001A   2FA0               MOV     R26, R16
     84          
     85          			// Check autoincrement status.
     86          			if(val=='a')
   \   0000001C   36A1               CPI     R26, 97
   \   0000001E   F421               BRNE    ??main_2
     87          			{
     88          				sendchar('Y'); // Yes, we do autoincrement.
   \   00000020   E509               LDI     R16, 89
   \   00000022   ........           CALL    sendchar
   \   00000026   CFF7               RJMP    ??main_1
     89          			}
     90          
     91          
     92          			// Set address.
     93          			else if(val=='A') // Set address...
   \                     ??main_2:
   \   00000028   34A1               CPI     R26, 65
   \   0000002A   F491               BRNE    ??main_3
     94          			{ // NOTE: Flash addresses are given in words, not bytes.
     95          				unsigned char high = recchar();
   \   0000002C   ........           CALL    recchar
   \   00000030   2E70               MOV     R7, R16
     96          				unsigned char low = recchar();
   \   00000032   ........           CALL    recchar
   \   00000036   2FB0               MOV     R27, R16
     97          				address = ((long)high<<8) | (long)low;
   \   00000038   2F0B               MOV     R16, R27
   \   0000003A   2D17               MOV     R17, R7
   \   0000003C   E020               LDI     R18, 0
   \   0000003E   E030               LDI     R19, 0
   \   00000040   8308               ST      Y, R16
   \   00000042   8319               STD     Y+1, R17
   \   00000044   832A               STD     Y+2, R18
   \   00000046   833B               STD     Y+3, R19
     98          				sendchar('\r'); // Send OK back.
   \   00000048   E00D               LDI     R16, 13
   \   0000004A   ........           CALL    sendchar
   \   0000004E   CFE3               RJMP    ??main_1
     99          			}
    100          
    101          			// Set 24-bit address.
    102          			else if(val=='H')
   \                     ??main_3:
   \   00000050   34A8               CPI     R26, 72
   \   00000052   F4A9               BRNE    ??main_4
    103          			{ // NOTE: Flash addresses are given in words, not bytes.
    104          				unsigned char highest = recchar();
   \   00000054   ........           CALL    recchar
   \   00000058   2FB0               MOV     R27, R16
    105          				unsigned char high = recchar();
   \   0000005A   ........           CALL    recchar
   \   0000005E   2E70               MOV     R7, R16
    106          				unsigned char low = recchar();
   \   00000060   ........           CALL    recchar
   \   00000064   2E80               MOV     R8, R16
    107          				address = ((long)highest << 16) | ((long)high << 8) | (long)low;
   \   00000066   2D08               MOV     R16, R8
   \   00000068   2D17               MOV     R17, R7
   \   0000006A   2F2B               MOV     R18, R27
   \   0000006C   E030               LDI     R19, 0
   \   0000006E   8308               ST      Y, R16
   \   00000070   8319               STD     Y+1, R17
   \   00000072   832A               STD     Y+2, R18
   \   00000074   833B               STD     Y+3, R19
    108          				sendchar('\r'); // Send OK back.
   \   00000076   E00D               LDI     R16, 13
   \   00000078   ........           CALL    sendchar
   \   0000007C   CFCC               RJMP    ??main_1
    109          			}
    110          
    111          			// Chip erase.
    112          			else if(val=='e')
   \                     ??main_4:
   \   0000007E   36A5               CPI     R26, 101
   \   00000080   F591               BRNE    ??main_5
    113          			{
    114          				for(address = 0; address < APP_END;address += PAGESIZE)
   \   00000082   E000               LDI     R16, 0
   \   00000084   E010               LDI     R17, 0
   \   00000086   E020               LDI     R18, 0
   \   00000088   E030               LDI     R19, 0
   \   0000008A   8308               ST      Y, R16
   \   0000008C   8319               STD     Y+1, R17
   \   0000008E   832A               STD     Y+2, R18
   \   00000090   833B               STD     Y+3, R19
   \                     ??main_6:
   \   00000092   8108               LD      R16, Y
   \   00000094   8119               LDD     R17, Y+1
   \   00000096   812A               LDD     R18, Y+2
   \   00000098   813B               LDD     R19, Y+3
   \   0000009A   3000               CPI     R16, 0
   \   0000009C   EF40               LDI     R20, 240
   \   0000009E   0714               CPC     R17, R20
   \   000000A0   E043               LDI     R20, 3
   \   000000A2   0724               CPC     R18, R20
   \   000000A4   E040               LDI     R20, 0
   \   000000A6   0734               CPC     R19, R20
   \   000000A8   F4D4               BRGE    ??main_7
    115          				{ // NOTE: Here we use address as a byte-address, not word-address, for convenience.
    116          					_WAIT_FOR_SPM();
   \                     ??main_8:
   \   000000AA   B707               IN      R16, 0x37
   \   000000AC   2F10               MOV     R17, R16
   \   000000AE   FD10               SBRC    R17, 0
   \   000000B0   CFFC               RJMP    ??main_8
    117          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    118          					_PAGE_ERASE( address );
   \   000000B2   E003               LDI     R16, 3
   \   000000B4   8148               LD      R20, Y
   \   000000B6   8159               LDD     R21, Y+1
   \   000000B8   816A               LDD     R22, Y+2
   \   000000BA   01FA               MOVW    R31:R30, R21:R20
   \   000000BC   2F36               MOV     R19, R22
   \   000000BE   BF3B               OUT     0x3B, R19
   \   000000C0   BF07               OUT     0x37, R16
   \   000000C2   95E8               SPM
    119          #pragma diag_default=Pe1053 // Back to default.
    120          				}
   \   000000C4   8108               LD      R16, Y
   \   000000C6   8119               LDD     R17, Y+1
   \   000000C8   812A               LDD     R18, Y+2
   \   000000CA   813B               LDD     R19, Y+3
   \   000000CC   5000               SUBI    R16, 0
   \   000000CE   4F1F               SBCI    R17, 255
   \   000000D0   4F2F               SBCI    R18, 255
   \   000000D2   4F3F               SBCI    R19, 255
   \   000000D4   8308               ST      Y, R16
   \   000000D6   8319               STD     Y+1, R17
   \   000000D8   832A               STD     Y+2, R18
   \   000000DA   833B               STD     Y+3, R19
   \   000000DC   CFDA               RJMP    ??main_6
    121          
    122          				sendchar('\r'); // Send OK back.
   \                     ??main_7:
   \   000000DE   E00D               LDI     R16, 13
   \   000000E0   ........           CALL    sendchar
   \   000000E4   CF98               RJMP    ??main_1
    123          			}
    124          
    125          #ifndef REMOVE_BLOCK_SUPPORT
    126          			// Check block load support.
    127          			else if(val=='b')
   \                     ??main_5:
   \   000000E6   36A2               CPI     R26, 98
   \   000000E8   F451               BRNE    ??main_9
    128          			{
    129          				sendchar('Y'); // Report block load supported.
   \   000000EA   E509               LDI     R16, 89
   \   000000EC   ........           CALL    sendchar
    130          				sendchar((BLOCKSIZE>>8) & 0xFF); // MSB first.
   \   000000F0   E001               LDI     R16, 1
   \   000000F2   ........           CALL    sendchar
    131          				sendchar(BLOCKSIZE&0xFF); // Report BLOCKSIZE (bytes).
   \   000000F6   E000               LDI     R16, 0
   \   000000F8   ........           CALL    sendchar
   \   000000FC   CF8C               RJMP    ??main_1
    132          			}
    133          
    134          
    135          			// Start block load.
    136          			else if(val=='B')
   \                     ??main_9:
   \   000000FE   34A2               CPI     R26, 66
   \   00000100   F489               BRNE    ??main_10
    137          			{
    138          				temp_int = (recchar()<<8) | recchar(); // Get block size.
   \   00000102   ........           CALL    recchar
   \   00000106   2FB0               MOV     R27, R16
   \   00000108   ........           CALL    recchar
   \   0000010C   2F1B               MOV     R17, R27
   \   0000010E   01C8               MOVW    R25:R24, R17:R16
    139          				val = recchar(); // Get memtype.
   \   00000110   ........           CALL    recchar
   \   00000114   2FA0               MOV     R26, R16
    140          				sendchar( BlockLoad(temp_int,val,&address) ); // Block load.
   \   00000116   01AE               MOVW    R21:R20, R29:R28
   \   00000118   2F2A               MOV     R18, R26
   \   0000011A   018C               MOVW    R17:R16, R25:R24
   \   0000011C   ....               RCALL   BlockLoad
   \   0000011E   ........           CALL    sendchar
   \   00000122   CF79               RJMP    ??main_1
    141          			}
    142          
    143          
    144          			// Start block read.
    145          			else if(val=='g')
   \                     ??main_10:
   \   00000124   36A7               CPI     R26, 103
   \   00000126   F479               BRNE    ??main_11
    146          			{
    147          				temp_int = (recchar()<<8) | recchar(); // Get block size.
   \   00000128   ........           CALL    recchar
   \   0000012C   2FB0               MOV     R27, R16
   \   0000012E   ........           CALL    recchar
   \   00000132   2F1B               MOV     R17, R27
   \   00000134   01C8               MOVW    R25:R24, R17:R16
    148          				val = recchar(); // Get memtype
   \   00000136   ........           CALL    recchar
   \   0000013A   2FA0               MOV     R26, R16
    149          				BlockRead(temp_int,val,&address); // Block read
   \   0000013C   01AE               MOVW    R21:R20, R29:R28
   \   0000013E   2F2A               MOV     R18, R26
   \   00000140   018C               MOVW    R17:R16, R25:R24
   \   00000142   ....               RCALL   BlockRead
   \   00000144   CF68               RJMP    ??main_1
    150          			}
    151          #endif
    152          
    153          #ifndef REMOVE_FLASH_BYTE_SUPPORT
    154          			// Read program memory.
    155          			else if(val=='R')
   \                     ??main_11:
   \   00000146   35A2               CPI     R26, 82
   \   00000148   F5B9               BRNE    ??main_12
    156          			{
    157          				// Send high byte, then low byte of flash word.
    158          				_WAIT_FOR_SPM();
   \                     ??main_13:
   \   0000014A   B707               IN      R16, 0x37
   \   0000014C   2F10               MOV     R17, R16
   \   0000014E   FD10               SBRC    R17, 0
   \   00000150   CFFC               RJMP    ??main_13
    159          				_ENABLE_RWW_SECTION();
   \   00000152   E111               LDI     R17, 17
   \   00000154   E000               LDI     R16, 0
   \   00000156   2E00               MOV     R0, R16
   \   00000158   BF17               OUT     0x37, R17
   \   0000015A   95E8               SPM
    160          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    161          				sendchar( _LOAD_PROGRAM_MEMORY( (address << 1)+1 ) );
   \   0000015C   8108               LD      R16, Y
   \   0000015E   8119               LDD     R17, Y+1
   \   00000160   812A               LDD     R18, Y+2
   \   00000162   0F00               LSL     R16
   \   00000164   1F11               ROL     R17
   \   00000166   1F22               ROL     R18
   \   00000168   5F0F               SUBI    R16, 255
   \   0000016A   4F1F               SBCI    R17, 255
   \   0000016C   4F2F               SBCI    R18, 255
   \   0000016E   01F8               MOVW    R31:R30, R17:R16
   \   00000170   2F32               MOV     R19, R18
   \   00000172   BF3B               OUT     0x3B, R19
   \   00000174   9006               ELPM    R0, Z
   \   00000176   E000               LDI     R16, 0
   \   00000178   BF0B               OUT     0x3B, R16
   \   0000017A   2D00               MOV     R16, R0
   \   0000017C   ........           CALL    sendchar
    162          				sendchar( _LOAD_PROGRAM_MEMORY( (address << 1)+0 ) );
   \   00000180   8108               LD      R16, Y
   \   00000182   8119               LDD     R17, Y+1
   \   00000184   812A               LDD     R18, Y+2
   \   00000186   0F00               LSL     R16
   \   00000188   1F11               ROL     R17
   \   0000018A   1F22               ROL     R18
   \   0000018C   01F8               MOVW    R31:R30, R17:R16
   \   0000018E   2F32               MOV     R19, R18
   \   00000190   BF3B               OUT     0x3B, R19
   \   00000192   9006               ELPM    R0, Z
   \   00000194   2D00               MOV     R16, R0
   \   00000196   E010               LDI     R17, 0
   \   00000198   BF1B               OUT     0x3B, R17
   \   0000019A   ........           CALL    sendchar
    163          #pragma diag_default=Pe1053 // Back to default.
    164          
    165          				address++; // Auto-advance to next Flash word.
   \   0000019E   8108               LD      R16, Y
   \   000001A0   8119               LDD     R17, Y+1
   \   000001A2   812A               LDD     R18, Y+2
   \   000001A4   813B               LDD     R19, Y+3
   \   000001A6   5F0F               SUBI    R16, 255
   \   000001A8   4F1F               SBCI    R17, 255
   \   000001AA   4F2F               SBCI    R18, 255
   \   000001AC   4F3F               SBCI    R19, 255
   \   000001AE   8308               ST      Y, R16
   \   000001B0   8319               STD     Y+1, R17
   \   000001B2   832A               STD     Y+2, R18
   \   000001B4   833B               STD     Y+3, R19
   \   000001B6   CF2F               RJMP    ??main_1
    166          			}
    167          
    168          
    169          			// Write program memory, low byte.
    170          			else if(val=='c')
   \                     ??main_12:
   \   000001B8   36A3               CPI     R26, 99
   \   000001BA   F441               BRNE    ??main_14
    171          			{ // NOTE: Always use this command before sending high byte.
    172          				temp_int=recchar(); // Get low byte for later _FILL_TEMP_WORD.
   \   000001BC   ........           CALL    recchar
   \   000001C0   E010               LDI     R17, 0
   \   000001C2   01C8               MOVW    R25:R24, R17:R16
    173          				sendchar('\r'); // Send OK back.
   \   000001C4   E00D               LDI     R16, 13
   \   000001C6   ........           CALL    sendchar
   \   000001CA   CF25               RJMP    ??main_1
    174          			}
    175          
    176          
    177          			// Write program memory, high byte.
    178          			else if(val=='C')
   \                     ??main_14:
   \   000001CC   34A3               CPI     R26, 67
   \   000001CE   F539               BRNE    ??main_15
    179          			{
    180          				temp_int |= (recchar()<<8); // Get and insert high byte.
   \   000001D0   ........           CALL    recchar
   \   000001D4   2F30               MOV     R19, R16
   \   000001D6   E020               LDI     R18, 0
   \   000001D8   2B82               OR      R24, R18
   \   000001DA   2B93               OR      R25, R19
    181          				_WAIT_FOR_SPM();
   \                     ??main_16:
   \   000001DC   B707               IN      R16, 0x37
   \   000001DE   2F10               MOV     R17, R16
   \   000001E0   FD10               SBRC    R17, 0
   \   000001E2   CFFC               RJMP    ??main_16
    182          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    183          				_FILL_TEMP_WORD( (address << 1), temp_int ); // Convert word-address to byte-address and fill.
   \   000001E4   E001               LDI     R16, 1
   \   000001E6   8148               LD      R20, Y
   \   000001E8   8159               LDD     R21, Y+1
   \   000001EA   816A               LDD     R22, Y+2
   \   000001EC   0F44               LSL     R20
   \   000001EE   1F55               ROL     R21
   \   000001F0   1F66               ROL     R22
   \   000001F2   01FA               MOVW    R31:R30, R21:R20
   \   000001F4   2F36               MOV     R19, R22
   \   000001F6   BF3B               OUT     0x3B, R19
   \   000001F8   010C               MOVW    R1:R0, R25:R24
   \   000001FA   BF07               OUT     0x37, R16
   \   000001FC   95E8               SPM
    184          #pragma diag_default=Pe1053 // Back to default.
    185          				address++; // Auto-advance to next Flash word.
   \   000001FE   8108               LD      R16, Y
   \   00000200   8119               LDD     R17, Y+1
   \   00000202   812A               LDD     R18, Y+2
   \   00000204   813B               LDD     R19, Y+3
   \   00000206   5F0F               SUBI    R16, 255
   \   00000208   4F1F               SBCI    R17, 255
   \   0000020A   4F2F               SBCI    R18, 255
   \   0000020C   4F3F               SBCI    R19, 255
   \   0000020E   8308               ST      Y, R16
   \   00000210   8319               STD     Y+1, R17
   \   00000212   832A               STD     Y+2, R18
   \   00000214   833B               STD     Y+3, R19
    186          				sendchar('\r'); // Send OK back.
   \   00000216   E00D               LDI     R16, 13
   \   00000218   ........           CALL    sendchar
   \   0000021C   CEFC               RJMP    ??main_1
    187          			}
    188          
    189          
    190          			// Write page.
    191          			else if(val== 'm')
   \                     ??main_15:
   \   0000021E   36AD               CPI     R26, 109
   \   00000220   F521               BRNE    ??main_17
    192          			{
    193          				if( address >= (APP_END>>1) ) // Protect bootloader area.
   \   00000222   8108               LD      R16, Y
   \   00000224   8119               LDD     R17, Y+1
   \   00000226   812A               LDD     R18, Y+2
   \   00000228   813B               LDD     R19, Y+3
   \   0000022A   3000               CPI     R16, 0
   \   0000022C   EF48               LDI     R20, 248
   \   0000022E   0714               CPC     R17, R20
   \   00000230   E041               LDI     R20, 1
   \   00000232   0724               CPC     R18, R20
   \   00000234   E040               LDI     R20, 0
   \   00000236   0734               CPC     R19, R20
   \   00000238   F024               BRLT    ??main_18
    194          				{
    195          					sendchar('?');
   \   0000023A   E30F               LDI     R16, 63
   \   0000023C   ........           CALL    sendchar
   \   00000240   C010               RJMP    ??main_19
    196          				} else
    197          				{
    198          					_WAIT_FOR_SPM();
   \                     ??main_18:
   \   00000242   B707               IN      R16, 0x37
   \   00000244   2F10               MOV     R17, R16
   \   00000246   FD10               SBRC    R17, 0
   \   00000248   CFFC               RJMP    ??main_18
    199          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    200          					_PAGE_WRITE( address << 1 ); // Convert word-address to byte-address and write.
   \   0000024A   E005               LDI     R16, 5
   \   0000024C   8148               LD      R20, Y
   \   0000024E   8159               LDD     R21, Y+1
   \   00000250   816A               LDD     R22, Y+2
   \   00000252   0F44               LSL     R20
   \   00000254   1F55               ROL     R21
   \   00000256   1F66               ROL     R22
   \   00000258   01FA               MOVW    R31:R30, R21:R20
   \   0000025A   2F36               MOV     R19, R22
   \   0000025C   BF3B               OUT     0x3B, R19
   \   0000025E   BF07               OUT     0x37, R16
   \   00000260   95E8               SPM
    201          #pragma diag_default=Pe1053 // Back to default.
    202          				}
    203          
    204          				sendchar('\r'); // Send OK back.
   \                     ??main_19:
   \   00000262   E00D               LDI     R16, 13
   \   00000264   ........           CALL    sendchar
   \   00000268   CED6               RJMP    ??main_1
    205          			}
    206          #endif
    207          
    208          #ifndef REMOVE_EEPROM_BYTE_SUPPORT
    209          			// Write EEPROM memory.
    210          			else if (val == 'D')
   \                     ??main_17:
   \   0000026A   34A4               CPI     R26, 68
   \   0000026C   F501               BRNE    ??main_20
    211          			{
    212          				_WAIT_FOR_SPM();
   \                     ??main_21:
   \   0000026E   B707               IN      R16, 0x37
   \   00000270   2F10               MOV     R17, R16
   \   00000272   FD10               SBRC    R17, 0
   \   00000274   CFFC               RJMP    ??main_21
    213          				EEARL = address; // Setup EEPROM address.
   \   00000276   8108               LD      R16, Y
   \   00000278   BD01               OUT     0x21, R16
    214          				EEARH = (address >> 8);
   \   0000027A   8119               LDD     R17, Y+1
   \   0000027C   2F01               MOV     R16, R17
   \   0000027E   BD02               OUT     0x22, R16
    215          				EEDR = recchar(); // Get byte.
   \   00000280   ........           CALL    recchar
   \   00000284   BD00               OUT     0x20, R16
    216          				EECR |= (1<<EEMWE); // Write byte.
   \   00000286   9AFA               SBI     0x1F, 0x02
    217          				EECR |= (1<<EEWE);
   \   00000288   9AF9               SBI     0x1F, 0x01
    218          				while (EECR & (1<<EEWE)) // Wait for write operation to finish.
   \                     ??main_22:
   \   0000028A   99F9               SBIC    0x1F, 0x01
   \   0000028C   CFFE               RJMP    ??main_22
    219          					;
    220          
    221          				address++; // Auto-advance to next EEPROM byte.
   \   0000028E   8108               LD      R16, Y
   \   00000290   8119               LDD     R17, Y+1
   \   00000292   812A               LDD     R18, Y+2
   \   00000294   813B               LDD     R19, Y+3
   \   00000296   5F0F               SUBI    R16, 255
   \   00000298   4F1F               SBCI    R17, 255
   \   0000029A   4F2F               SBCI    R18, 255
   \   0000029C   4F3F               SBCI    R19, 255
   \   0000029E   8308               ST      Y, R16
   \   000002A0   8319               STD     Y+1, R17
   \   000002A2   832A               STD     Y+2, R18
   \   000002A4   833B               STD     Y+3, R19
    222          				sendchar('\r');// Send OK back.
   \   000002A6   E00D               LDI     R16, 13
   \   000002A8   ........           CALL    sendchar
   \   000002AC   CEB4               RJMP    ??main_1
    223          			}
    224          
    225          
    226          			// Read EEPROM memory.
    227          			else if (val == 'd')
   \                     ??main_20:
   \   000002AE   36A4               CPI     R26, 100
   \   000002B0   F4B1               BRNE    ??main_23
    228          			{
    229          				EEARL = address; // Setup EEPROM address.
   \   000002B2   8108               LD      R16, Y
   \   000002B4   BD01               OUT     0x21, R16
    230          				EEARH = (address >> 8);
   \   000002B6   8119               LDD     R17, Y+1
   \   000002B8   2F01               MOV     R16, R17
   \   000002BA   BD02               OUT     0x22, R16
    231          				EECR |= (1<<EERE); // Read byte...
   \   000002BC   9AF8               SBI     0x1F, 0x00
    232          				sendchar(EEDR); // ...and send it back.
   \   000002BE   B500               IN      R16, 0x20
   \   000002C0   ........           CALL    sendchar
    233          				address++; // Auto-advance to next EEPROM byte.
   \   000002C4   8108               LD      R16, Y
   \   000002C6   8119               LDD     R17, Y+1
   \   000002C8   812A               LDD     R18, Y+2
   \   000002CA   813B               LDD     R19, Y+3
   \   000002CC   5F0F               SUBI    R16, 255
   \   000002CE   4F1F               SBCI    R17, 255
   \   000002D0   4F2F               SBCI    R18, 255
   \   000002D2   4F3F               SBCI    R19, 255
   \   000002D4   8308               ST      Y, R16
   \   000002D6   8319               STD     Y+1, R17
   \   000002D8   832A               STD     Y+2, R18
   \   000002DA   833B               STD     Y+3, R19
   \   000002DC   CE9C               RJMP    ??main_1
    234          			}
    235          #endif
    236          
    237          #ifndef REMOVE_FUSE_AND_LOCK_BIT_SUPPORT
    238          			// Write lockbits.
    239          			else if(val=='l')
   \                     ??main_23:
   \   000002DE   36AC               CPI     R26, 108
   \   000002E0   F479               BRNE    ??main_24
    240          			{
    241          				_WAIT_FOR_SPM();
   \                     ??main_25:
   \   000002E2   B707               IN      R16, 0x37
   \   000002E4   2F10               MOV     R17, R16
   \   000002E6   FD10               SBRC    R17, 0
   \   000002E8   CFFC               RJMP    ??main_25
    242          				_SET_LOCK_BITS( recchar() ); // Read and set lock bits.
   \   000002EA   ........           CALL    recchar
   \   000002EE   2F10               MOV     R17, R16
   \   000002F0   E009               LDI     R16, 9
   \   000002F2   2E01               MOV     R0, R17
   \   000002F4   BF07               OUT     0x37, R16
   \   000002F6   95E8               SPM
    243          				sendchar('\r'); // Send OK back.
   \   000002F8   E00D               LDI     R16, 13
   \   000002FA   ........           CALL    sendchar
   \   000002FE   CE8B               RJMP    ??main_1
    244          			}
    245          
    246          
    247          			// Read lock bits.
    248          			else if(val=='r')
   \                     ??main_24:
   \   00000300   37A2               CPI     R26, 114
   \   00000302   F469               BRNE    ??main_26
    249          			{
    250          				_WAIT_FOR_SPM();
   \                     ??main_27:
   \   00000304   B707               IN      R16, 0x37
   \   00000306   2F10               MOV     R17, R16
   \   00000308   FD10               SBRC    R17, 0
   \   0000030A   CFFC               RJMP    ??main_27
    251          				sendchar( _GET_LOCK_BITS() );
   \   0000030C   E009               LDI     R16, 9
   \   0000030E   E0E1               LDI     R30, 1
   \   00000310   E0F0               LDI     R31, 0
   \   00000312   BF07               OUT     0x37, R16
   \   00000314   9114               LPM     R17, Z
   \   00000316   2F01               MOV     R16, R17
   \   00000318   ........           CALL    sendchar
   \   0000031C   CE7C               RJMP    ??main_1
    252          			}
    253          
    254          
    255          			// Read fuse bits.
    256          			else if(val=='F')
   \                     ??main_26:
   \   0000031E   34A6               CPI     R26, 70
   \   00000320   F469               BRNE    ??main_28
    257          			{
    258          				_WAIT_FOR_SPM();
   \                     ??main_29:
   \   00000322   B707               IN      R16, 0x37
   \   00000324   2F10               MOV     R17, R16
   \   00000326   FD10               SBRC    R17, 0
   \   00000328   CFFC               RJMP    ??main_29
    259          				sendchar( _GET_LOW_FUSES() );
   \   0000032A   E009               LDI     R16, 9
   \   0000032C   E0E0               LDI     R30, 0
   \   0000032E   E0F0               LDI     R31, 0
   \   00000330   BF07               OUT     0x37, R16
   \   00000332   9114               LPM     R17, Z
   \   00000334   2F01               MOV     R16, R17
   \   00000336   ........           CALL    sendchar
   \   0000033A   CE6D               RJMP    ??main_1
    260          			}
    261          
    262          
    263          			// Read high fuse bits.
    264          			else if(val=='N')
   \                     ??main_28:
   \   0000033C   34AE               CPI     R26, 78
   \   0000033E   F469               BRNE    ??main_30
    265          			{
    266          				_WAIT_FOR_SPM();
   \                     ??main_31:
   \   00000340   B707               IN      R16, 0x37
   \   00000342   2F10               MOV     R17, R16
   \   00000344   FD10               SBRC    R17, 0
   \   00000346   CFFC               RJMP    ??main_31
    267          				sendchar( _GET_HIGH_FUSES() );
   \   00000348   E009               LDI     R16, 9
   \   0000034A   E0E3               LDI     R30, 3
   \   0000034C   E0F0               LDI     R31, 0
   \   0000034E   BF07               OUT     0x37, R16
   \   00000350   9114               LPM     R17, Z
   \   00000352   2F01               MOV     R16, R17
   \   00000354   ........           CALL    sendchar
   \   00000358   CE5E               RJMP    ??main_1
    268          			}
    269          
    270          
    271          			// Read extended fuse bits.
    272          			else if(val=='Q')
   \                     ??main_30:
   \   0000035A   35A1               CPI     R26, 81
   \   0000035C   F469               BRNE    ??main_32
    273          			{
    274          				_WAIT_FOR_SPM();
   \                     ??main_33:
   \   0000035E   B707               IN      R16, 0x37
   \   00000360   2F10               MOV     R17, R16
   \   00000362   FD10               SBRC    R17, 0
   \   00000364   CFFC               RJMP    ??main_33
    275          				sendchar( _GET_EXTENDED_FUSES() );
   \   00000366   E009               LDI     R16, 9
   \   00000368   E0E2               LDI     R30, 2
   \   0000036A   E0F0               LDI     R31, 0
   \   0000036C   BF07               OUT     0x37, R16
   \   0000036E   9114               LPM     R17, Z
   \   00000370   2F01               MOV     R16, R17
   \   00000372   ........           CALL    sendchar
   \   00000376   CE4F               RJMP    ??main_1
    276          			}
    277          #endif
    278          
    279          #ifndef REMOVE_AVRPROG_SUPPORT
    280          			// Enter and leave programming mode.
    281          			else if((val=='P')||(val=='L'))
    282          			{
    283          				sendchar('\r'); // Nothing special to do, just answer OK.
    284          			}
    285          
    286          
    287          			// Exit bootloader.
    288          			else if(val=='E')
    289          			{
    290          				_WAIT_FOR_SPM();
    291          				_ENABLE_RWW_SECTION();
    292          				sendchar('\r');
    293          				funcptr(); // Jump to Reset vector 0x0000 in Application Section.
    294          			}
    295          
    296          
    297          			// Get programmer type.
    298          			else if (val=='p')
    299          			{
    300          				sendchar('S'); // Answer 'SERIAL'.
    301          			}
    302          
    303          
    304          			// Return supported device codes.
    305          			else if(val=='t')
    306          			{
    307          				sendchar( PARTCODE ); // Supports only this device, of course.
    308          				sendchar( 0 ); // Send list terminator.
    309          			}
    310          
    311          
    312          			// Set LED, clear LED and set device type.
    313          			else if((val=='x')||(val=='y')||(val=='T'))
    314          			{
    315          				recchar(); // Ignore the command and it's parameter.
    316          				sendchar('\r'); // Send OK back.
    317          			}
    318          #endif
    319          
    320          			// Return programmer identifier.
    321          			else if(val=='S')
   \                     ??main_32:
   \   00000378   35A3               CPI     R26, 83
   \   0000037A   F4B1               BRNE    ??main_34
    322          			{
    323          				sendchar('A'); // Return 'AVRBOOT'.
   \   0000037C   E401               LDI     R16, 65
   \   0000037E   ........           CALL    sendchar
    324          				sendchar('V'); // Software identifier (aka programmer signature) is always 7 characters.
   \   00000382   E506               LDI     R16, 86
   \   00000384   ........           CALL    sendchar
    325          				sendchar('R');
   \   00000388   E502               LDI     R16, 82
   \   0000038A   ........           CALL    sendchar
    326          				sendchar('B');
   \   0000038E   E402               LDI     R16, 66
   \   00000390   ........           CALL    sendchar
    327          				sendchar('O');
   \   00000394   E40F               LDI     R16, 79
   \   00000396   ........           CALL    sendchar
    328          				sendchar('O');
   \   0000039A   E40F               LDI     R16, 79
   \   0000039C   ........           CALL    sendchar
    329          				sendchar('T');
   \   000003A0   E504               LDI     R16, 84
   \   000003A2   ........           CALL    sendchar
   \   000003A6   CE37               RJMP    ??main_1
    330          			}
    331          
    332          
    333          			// Return software version.
    334          			else if(val=='V')
   \                     ??main_34:
   \   000003A8   35A6               CPI     R26, 86
   \   000003AA   F439               BRNE    ??main_35
    335          			{
    336          				sendchar('1');
   \   000003AC   E301               LDI     R16, 49
   \   000003AE   ........           CALL    sendchar
    337          				sendchar('5');
   \   000003B2   E305               LDI     R16, 53
   \   000003B4   ........           CALL    sendchar
   \   000003B8   CE2E               RJMP    ??main_1
    338          			}
    339          
    340          
    341          			// Return signature bytes.
    342          			else if(val=='s')
   \                     ??main_35:
   \   000003BA   37A3               CPI     R26, 115
   \   000003BC   F451               BRNE    ??main_36
    343          			{
    344          				sendchar( SIGNATURE_BYTE_3 );
   \   000003BE   E001               LDI     R16, 1
   \   000003C0   ........           CALL    sendchar
    345          				sendchar( SIGNATURE_BYTE_2 );
   \   000003C4   E908               LDI     R16, 152
   \   000003C6   ........           CALL    sendchar
    346          				sendchar( SIGNATURE_BYTE_1 );
   \   000003CA   E10E               LDI     R16, 30
   \   000003CC   ........           CALL    sendchar
   \   000003D0   CE22               RJMP    ??main_1
    347          			}
    348          
    349          
    350          			// The last command to accept is ESC (synchronization).
    351          			else if(val!=0x1b)                  // If not ESC, then it is unrecognized...
   \                     ??main_36:
   \   000003D2   31AB               CPI     R26, 27
   \   000003D4   F409               BRNE    $+2+2
   \   000003D6   CE1F               RJMP    ??main_1
    352          			{
    353          				sendchar('?');
   \   000003D8   E30F               LDI     R16, 63
   \   000003DA   ........           CALL    sendchar
   \   000003DE   CE1B               RJMP    ??main_1
    354          			}
    355          		} // end: for(;;)
    356          	}
    357          	else
    358          	{
    359          		_WAIT_FOR_SPM();
   \                     ??main_0:
   \   000003E0   B707               IN      R16, 0x37
   \   000003E2   2F10               MOV     R17, R16
   \   000003E4   FD10               SBRC    R17, 0
   \   000003E6   CFFC               RJMP    ??main_0
    360          		_ENABLE_RWW_SECTION();
   \   000003E8   E111               LDI     R17, 17
   \   000003EA   E000               LDI     R16, 0
   \   000003EC   2E00               MOV     R0, R16
   \   000003EE   BF17               OUT     0x37, R17
   \   000003F0   95E8               SPM
    361          		funcptr(); // Jump to Reset vector 0x0000 in Application Section.
   \   000003F2   01F2               MOVW    R31:R30, R5:R4
   \   000003F4   BE6C               OUT     0x3C, R6
   \   000003F6   9519               EICALL
    362          	}
    363          } // end: main
   \   000003F8   9624               ADIW    R29:R28, 4
   \   000003FA   9508               RET
    364          
    365          
    366          #ifndef REMOVE_BLOCK_SUPPORT
    367          /*! \brief  Write block from serial port and program mem.
    368           *
    369           *  Read 'size' bytes from serial port and write to EPROM/Flash
    370           *  memory 'address'.
    371           *  If 'mem' == 'E', then 'address' gives
    372           *  the byte address in EEPROM. If 'mem' == 'F', then 'address'
    373           *  gives the word address in Flash.
    374           */

   \                                 In segment FARCODE, align 2, keep-with-next
    375          unsigned char BlockLoad(unsigned int size, unsigned char mem, long *address)
   \                     BlockLoad:
    376          {
   \   00000000   ........           CALL    ?PROLOGUE11_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004                      REQUIRE ?Register_R5_is_cg_reg
   \   00000004                      REQUIRE ?Register_R6_is_cg_reg
   \   00000004                      REQUIRE ?Register_R7_is_cg_reg
   \   00000004                      REQUIRE ?Register_R8_is_cg_reg
   \   00000004                      REQUIRE ?Register_R9_is_cg_reg
   \   00000004                      REQUIRE ?Register_R10_is_cg_reg
   \   00000004   50D1               SUBI    R29, 1
   \   00000006   0148               MOVW    R9:R8, R17:R16
   \   00000008   2EA2               MOV     R10, R18
   \   0000000A   012A               MOVW    R5:R4, R21:R20
    377          	unsigned char buffer[BLOCKSIZE];
    378          	unsigned int data;
    379          	long tempaddress;
    380          
    381          	// EEPROM memory type.
    382          	if(mem=='E')
   \   0000000C   E405               LDI     R16, 69
   \   0000000E   16A0               CP      R10, R16
   \   00000010   F009               BREQ    $+2+2
   \   00000012   C04D               RJMP    ??BlockLoad_0
    383          	{
    384          		/* Fill buffer first, as EEPROM is too slow to copy with UART speed */
    385          		for(tempaddress=0;tempaddress<size;tempaddress++)
   \   00000014   E080               LDI     R24, 0
   \   00000016   E090               LDI     R25, 0
   \   00000018   E0A0               LDI     R26, 0
   \   0000001A   E0B0               LDI     R27, 0
   \                     ??BlockLoad_1:
   \   0000001C   0184               MOVW    R17:R16, R9:R8
   \   0000001E   E020               LDI     R18, 0
   \   00000020   E030               LDI     R19, 0
   \   00000022   1780               CP      R24, R16
   \   00000024   0791               CPC     R25, R17
   \   00000026   07A2               CPC     R26, R18
   \   00000028   07B3               CPC     R27, R19
   \   0000002A   F464               BRGE    ??BlockLoad_2
    386          			buffer[tempaddress] = recchar();
   \   0000002C   ........           CALL    recchar
   \   00000030   01FE               MOVW    R31:R30, R29:R28
   \   00000032   019C               MOVW    R19:R18, R25:R24
   \   00000034   0FE2               ADD     R30, R18
   \   00000036   1FF3               ADC     R31, R19
   \   00000038   8300               ST      Z, R16
   \   0000003A   5F8F               SUBI    R24, 255
   \   0000003C   4F9F               SBCI    R25, 255
   \   0000003E   4FAF               SBCI    R26, 255
   \   00000040   4FBF               SBCI    R27, 255
   \   00000042   CFEC               RJMP    ??BlockLoad_1
    387          
    388          		/* Then program the EEPROM */
    389          		_WAIT_FOR_SPM();
   \                     ??BlockLoad_2:
   \   00000044   B707               IN      R16, 0x37
   \   00000046   2F10               MOV     R17, R16
   \   00000048   FD10               SBRC    R17, 0
   \   0000004A   CFFC               RJMP    ??BlockLoad_2
    390          		for( tempaddress=0; tempaddress < size; tempaddress++)
   \   0000004C   E080               LDI     R24, 0
   \   0000004E   E090               LDI     R25, 0
   \   00000050   E0A0               LDI     R26, 0
   \   00000052   E0B0               LDI     R27, 0
   \                     ??BlockLoad_3:
   \   00000054   0184               MOVW    R17:R16, R9:R8
   \   00000056   E020               LDI     R18, 0
   \   00000058   E030               LDI     R19, 0
   \   0000005A   1780               CP      R24, R16
   \   0000005C   0791               CPC     R25, R17
   \   0000005E   07A2               CPC     R26, R18
   \   00000060   07B3               CPC     R27, R19
   \   00000062   F51C               BRGE    ??BlockLoad_4
    391          		{
    392          			EEARL = *address; // Setup EEPROM address
   \   00000064   01F2               MOVW    R31:R30, R5:R4
   \   00000066   8100               LD      R16, Z
   \   00000068   BD01               OUT     0x21, R16
    393          			EEARH = ((*address) >> 8);
   \   0000006A   01F2               MOVW    R31:R30, R5:R4
   \   0000006C   8111               LDD     R17, Z+1
   \   0000006E   2F01               MOV     R16, R17
   \   00000070   BD02               OUT     0x22, R16
    394          			EEDR = buffer[tempaddress]; // Get byte.
   \   00000072   01FE               MOVW    R31:R30, R29:R28
   \   00000074   018C               MOVW    R17:R16, R25:R24
   \   00000076   0FE0               ADD     R30, R16
   \   00000078   1FF1               ADC     R31, R17
   \   0000007A   8100               LD      R16, Z
   \   0000007C   BD00               OUT     0x20, R16
    395          			EECR |= (1<<EEMWE); // Write byte.
   \   0000007E   9AFA               SBI     0x1F, 0x02
    396          			EECR |= (1<<EEWE);
   \   00000080   9AF9               SBI     0x1F, 0x01
    397          			while (EECR & (1<<EEWE)) // Wait for write operation to finish.
   \                     ??BlockLoad_5:
   \   00000082   99F9               SBIC    0x1F, 0x01
   \   00000084   CFFE               RJMP    ??BlockLoad_5
    398          				;
    399          
    400          			(*address)++; // Select next EEPROM byte
   \   00000086   01F2               MOVW    R31:R30, R5:R4
   \   00000088   8100               LD      R16, Z
   \   0000008A   8111               LDD     R17, Z+1
   \   0000008C   8122               LDD     R18, Z+2
   \   0000008E   8133               LDD     R19, Z+3
   \   00000090   5F0F               SUBI    R16, 255
   \   00000092   4F1F               SBCI    R17, 255
   \   00000094   4F2F               SBCI    R18, 255
   \   00000096   4F3F               SBCI    R19, 255
   \   00000098   8300               ST      Z, R16
   \   0000009A   8311               STD     Z+1, R17
   \   0000009C   8322               STD     Z+2, R18
   \   0000009E   8333               STD     Z+3, R19
    401          		}
   \   000000A0   5F8F               SUBI    R24, 255
   \   000000A2   4F9F               SBCI    R25, 255
   \   000000A4   4FAF               SBCI    R26, 255
   \   000000A6   4FBF               SBCI    R27, 255
   \   000000A8   CFD5               RJMP    ??BlockLoad_3
    402          
    403          		return '\r'; // Report programming OK
   \                     ??BlockLoad_4:
   \   000000AA   E00D               LDI     R16, 13
   \   000000AC   C06A               RJMP    ??BlockLoad_6
    404          	}
    405          
    406          	// Flash memory type.
    407          	else if(mem=='F')
   \                     ??BlockLoad_0:
   \   000000AE   E406               LDI     R16, 70
   \   000000B0   16A0               CP      R10, R16
   \   000000B2   F009               BREQ    $+2+2
   \   000000B4   C065               RJMP    ??BlockLoad_7
    408          	{ // NOTE: For flash programming, 'address' is given in words.
    409          		(*address) <<= 1; // Convert address to bytes temporarily.
   \   000000B6   01F2               MOVW    R31:R30, R5:R4
   \   000000B8   8100               LD      R16, Z
   \   000000BA   8111               LDD     R17, Z+1
   \   000000BC   8122               LDD     R18, Z+2
   \   000000BE   8133               LDD     R19, Z+3
   \   000000C0   0F00               LSL     R16
   \   000000C2   1F11               ROL     R17
   \   000000C4   1F22               ROL     R18
   \   000000C6   1F33               ROL     R19
   \   000000C8   01F2               MOVW    R31:R30, R5:R4
   \   000000CA   8300               ST      Z, R16
   \   000000CC   8311               STD     Z+1, R17
   \   000000CE   8322               STD     Z+2, R18
   \   000000D0   8333               STD     Z+3, R19
    410          		tempaddress = (*address);  // Store address in page.
   \   000000D2   01F2               MOVW    R31:R30, R5:R4
   \   000000D4   8100               LD      R16, Z
   \   000000D6   8111               LDD     R17, Z+1
   \   000000D8   8122               LDD     R18, Z+2
   \   000000DA   8133               LDD     R19, Z+3
   \   000000DC   01C8               MOVW    R25:R24, R17:R16
   \   000000DE   01D9               MOVW    R27:R26, R19:R18
    411          
    412          		do
    413          		{
    414          			data = recchar();
   \                     ??BlockLoad_8:
   \   000000E0   ........           CALL    recchar
   \   000000E4   E010               LDI     R17, 0
   \   000000E6   0138               MOVW    R7:R6, R17:R16
    415          			data |= (recchar() << 8);
   \   000000E8   ........           CALL    recchar
   \   000000EC   2F30               MOV     R19, R16
   \   000000EE   E020               LDI     R18, 0
   \   000000F0   2A62               OR      R6, R18
   \   000000F2   2A73               OR      R7, R19
    416          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    417          			_FILL_TEMP_WORD(*address,data);
   \   000000F4   E041               LDI     R20, 1
   \   000000F6   01F2               MOVW    R31:R30, R5:R4
   \   000000F8   8100               LD      R16, Z
   \   000000FA   8111               LDD     R17, Z+1
   \   000000FC   8122               LDD     R18, Z+2
   \   000000FE   01F8               MOVW    R31:R30, R17:R16
   \   00000100   2F32               MOV     R19, R18
   \   00000102   BF3B               OUT     0x3B, R19
   \   00000104   0103               MOVW    R1:R0, R7:R6
   \   00000106   BF47               OUT     0x37, R20
   \   00000108   95E8               SPM
    418          #pragma diag_default=Pe1053 // Back to default.
    419          			(*address)+=2; // Select next word in memory.
   \   0000010A   01F2               MOVW    R31:R30, R5:R4
   \   0000010C   8100               LD      R16, Z
   \   0000010E   8111               LDD     R17, Z+1
   \   00000110   8122               LDD     R18, Z+2
   \   00000112   8133               LDD     R19, Z+3
   \   00000114   5F0E               SUBI    R16, 254
   \   00000116   4F1F               SBCI    R17, 255
   \   00000118   4F2F               SBCI    R18, 255
   \   0000011A   4F3F               SBCI    R19, 255
   \   0000011C   8300               ST      Z, R16
   \   0000011E   8311               STD     Z+1, R17
   \   00000120   8322               STD     Z+2, R18
   \   00000122   8333               STD     Z+3, R19
    420          			size -= 2; // Reduce number of bytes to write by two.
   \   00000124   EF0E               LDI     R16, 254
   \   00000126   0E80               ADD     R8, R16
   \   00000128   EF0F               LDI     R16, 255
   \   0000012A   1E90               ADC     R9, R16
    421          		} while(size); // Loop until all bytes written.
   \   0000012C   2D08               MOV     R16, R8
   \   0000012E   2909               OR      R16, R9
   \   00000130   F6B9               BRNE    ??BlockLoad_8
    422          
    423          		if( tempaddress < (APP_END) ) { // Protect bootloader area.
   \   00000132   3080               CPI     R24, 0
   \   00000134   EF00               LDI     R16, 240
   \   00000136   0790               CPC     R25, R16
   \   00000138   E003               LDI     R16, 3
   \   0000013A   07A0               CPC     R26, R16
   \   0000013C   E000               LDI     R16, 0
   \   0000013E   07B0               CPC     R27, R16
   \   00000140   F454               BRGE    ??BlockLoad_9
    424          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    425          			_PAGE_WRITE(tempaddress);
   \   00000142   E005               LDI     R16, 5
   \   00000144   01FC               MOVW    R31:R30, R25:R24
   \   00000146   2F3A               MOV     R19, R26
   \   00000148   BF3B               OUT     0x3B, R19
   \   0000014A   BF07               OUT     0x37, R16
   \   0000014C   95E8               SPM
    426          #pragma diag_default=Pe1053 // Back to default.
    427          			_WAIT_FOR_SPM();
   \                     ??BlockLoad_10:
   \   0000014E   B707               IN      R16, 0x37
   \   00000150   2F10               MOV     R17, R16
   \   00000152   FD10               SBRC    R17, 0
   \   00000154   CFFC               RJMP    ??BlockLoad_10
    428          		}
    429          		_ENABLE_RWW_SECTION();
   \                     ??BlockLoad_9:
   \   00000156   E111               LDI     R17, 17
   \   00000158   E000               LDI     R16, 0
   \   0000015A   2E00               MOV     R0, R16
   \   0000015C   BF17               OUT     0x37, R17
   \   0000015E   95E8               SPM
    430          
    431          		(*address) >>= 1; // Convert address back to Flash words again.
   \   00000160   01F2               MOVW    R31:R30, R5:R4
   \   00000162   8100               LD      R16, Z
   \   00000164   8111               LDD     R17, Z+1
   \   00000166   8122               LDD     R18, Z+2
   \   00000168   8133               LDD     R19, Z+3
   \   0000016A   9535               ASR     R19
   \   0000016C   9527               ROR     R18
   \   0000016E   9517               ROR     R17
   \   00000170   9507               ROR     R16
   \   00000172   01F2               MOVW    R31:R30, R5:R4
   \   00000174   8300               ST      Z, R16
   \   00000176   8311               STD     Z+1, R17
   \   00000178   8322               STD     Z+2, R18
   \   0000017A   8333               STD     Z+3, R19
    432          		return '\r'; // Report programming OK
   \   0000017C   E00D               LDI     R16, 13
   \   0000017E   C001               RJMP    ??BlockLoad_6
    433          	}
    434          
    435          	// Invalid memory type?
    436          	else
    437          	{
    438          		return '?';
   \                     ??BlockLoad_7:
   \   00000180   E30F               LDI     R16, 63
   \                     ??BlockLoad_6:
   \   00000182   5FDF               SUBI    R29, 255
   \   00000184   E0EB               LDI     R30, 11
   \   00000186   ........           JMP     ?EPILOGUE_B11_L09
    439          	}
    440          }
    441          
    442          
    443          
    444          /*! \brief  Read block of mem and send to serial port.
    445           *
    446           *  Read 'size' bytes from EEPROM/Flash memory 'address' and
    447           *  send to serial port. If 'mem' == 'E', then 'address' gives
    448           *  the byte address in EEPROM. If 'mem' == 'F', then 'address'
    449           *  gives the word address in Flash.
    450           */

   \                                 In segment FARCODE, align 2, keep-with-next
    451          void BlockRead(unsigned int size, unsigned char mem, long *address)
   \                     BlockRead:
    452          {
   \   00000000   ........           CALL    ?PROLOGUE5_L09
   \   00000004                      REQUIRE ?Register_R4_is_cg_reg
   \   00000004   01C8               MOVW    R25:R24, R17:R16
   \   00000006   2E42               MOV     R4, R18
   \   00000008   01DA               MOVW    R27:R26, R21:R20
    453          	// EEPROM memory type.
    454          	if (mem=='E') // Read EEPROM
   \   0000000A   E405               LDI     R16, 69
   \   0000000C   1640               CP      R4, R16
   \   0000000E   F509               BRNE    ??BlockRead_0
    455          	{
    456          		do
    457          		{
    458          			EEARL = *address; // Setup EEPROM address
   \                     ??BlockRead_1:
   \   00000010   910D               LD      R16, X+
   \   00000012   911D               LD      R17, X+
   \   00000014   912D               LD      R18, X+
   \   00000016   9713               SBIW    R27:R26, 3
   \   00000018   BD01               OUT     0x21, R16
    459          			EEARH = ((*address) >> 8);
   \   0000001A   910D               LD      R16, X+
   \   0000001C   911D               LD      R17, X+
   \   0000001E   912D               LD      R18, X+
   \   00000020   9713               SBIW    R27:R26, 3
   \   00000022   2F01               MOV     R16, R17
   \   00000024   BD02               OUT     0x22, R16
    460          			(*address)++; // Select next EEPROM byte
   \   00000026   01FD               MOVW    R31:R30, R27:R26
   \   00000028   8100               LD      R16, Z
   \   0000002A   8111               LDD     R17, Z+1
   \   0000002C   8122               LDD     R18, Z+2
   \   0000002E   8133               LDD     R19, Z+3
   \   00000030   5F0F               SUBI    R16, 255
   \   00000032   4F1F               SBCI    R17, 255
   \   00000034   4F2F               SBCI    R18, 255
   \   00000036   4F3F               SBCI    R19, 255
   \   00000038   8300               ST      Z, R16
   \   0000003A   8311               STD     Z+1, R17
   \   0000003C   8322               STD     Z+2, R18
   \   0000003E   8333               STD     Z+3, R19
    461          			EECR |= (1<<EERE); // Read EEPROM
   \   00000040   9AF8               SBI     0x1F, 0x00
    462          			sendchar(EEDR); // Transmit EEPROM dat ato PC
   \   00000042   B500               IN      R16, 0x20
   \   00000044   ........           CALL    sendchar
    463          
    464          			size--; // Decrease number of bytes to read
   \   00000048   9701               SBIW    R25:R24, 1
    465          		} while (size); // Repeat until all block has been read
   \   0000004A   2F08               MOV     R16, R24
   \   0000004C   2B09               OR      R16, R25
   \   0000004E   F701               BRNE    ??BlockRead_1
   \   00000050   C04C               RJMP    ??BlockRead_2
    466          	}
    467          
    468          	// Flash memory type.
    469          	else if(mem=='F')
   \                     ??BlockRead_0:
   \   00000052   E406               LDI     R16, 70
   \   00000054   1640               CP      R4, R16
   \   00000056   F009               BREQ    $+2+2
   \   00000058   C048               RJMP    ??BlockRead_2
    470          	{
    471          		(*address) <<= 1; // Convert address to bytes temporarily.
   \   0000005A   910D               LD      R16, X+
   \   0000005C   911D               LD      R17, X+
   \   0000005E   912D               LD      R18, X+
   \   00000060   913C               LD      R19, X
   \   00000062   9713               SBIW    R27:R26, 3
   \   00000064   0F00               LSL     R16
   \   00000066   1F11               ROL     R17
   \   00000068   1F22               ROL     R18
   \   0000006A   1F33               ROL     R19
   \   0000006C   930D               ST      X+, R16
   \   0000006E   931D               ST      X+, R17
   \   00000070   932D               ST      X+, R18
   \   00000072   933C               ST      X, R19
   \   00000074   9713               SBIW    R27:R26, 3
    472          
    473          		do
    474          		{
    475          #pragma diag_suppress=Pe1053 // Suppress warning for conversion from long-type address to flash ptr.
    476          			sendchar( _LOAD_PROGRAM_MEMORY(*address) );
   \                     ??BlockRead_3:
   \   00000076   910D               LD      R16, X+
   \   00000078   911D               LD      R17, X+
   \   0000007A   912D               LD      R18, X+
   \   0000007C   9713               SBIW    R27:R26, 3
   \   0000007E   01F8               MOVW    R31:R30, R17:R16
   \   00000080   2F32               MOV     R19, R18
   \   00000082   BF3B               OUT     0x3B, R19
   \   00000084   9006               ELPM    R0, Z
   \   00000086   E000               LDI     R16, 0
   \   00000088   BF0B               OUT     0x3B, R16
   \   0000008A   2D00               MOV     R16, R0
   \   0000008C   ........           CALL    sendchar
    477          			sendchar( _LOAD_PROGRAM_MEMORY((*address)+1) );
   \   00000090   910D               LD      R16, X+
   \   00000092   911D               LD      R17, X+
   \   00000094   912D               LD      R18, X+
   \   00000096   9713               SBIW    R27:R26, 3
   \   00000098   5F0F               SUBI    R16, 255
   \   0000009A   4F1F               SBCI    R17, 255
   \   0000009C   4F2F               SBCI    R18, 255
   \   0000009E   01F8               MOVW    R31:R30, R17:R16
   \   000000A0   2F32               MOV     R19, R18
   \   000000A2   BF3B               OUT     0x3B, R19
   \   000000A4   9006               ELPM    R0, Z
   \   000000A6   2D00               MOV     R16, R0
   \   000000A8   E010               LDI     R17, 0
   \   000000AA   BF1B               OUT     0x3B, R17
   \   000000AC   ........           CALL    sendchar
    478          #pragma diag_default=Pe1053 // Back to default.
    479          			(*address) += 2; // Select next word in memory.
   \   000000B0   910D               LD      R16, X+
   \   000000B2   911D               LD      R17, X+
   \   000000B4   912D               LD      R18, X+
   \   000000B6   913C               LD      R19, X
   \   000000B8   5F0E               SUBI    R16, 254
   \   000000BA   4F1F               SBCI    R17, 255
   \   000000BC   4F2F               SBCI    R18, 255
   \   000000BE   4F3F               SBCI    R19, 255
   \   000000C0   933C               ST      X, R19
   \   000000C2   932E               ST      -X, R18
   \   000000C4   931E               ST      -X, R17
   \   000000C6   930E               ST      -X, R16
    480          			size -= 2; // Subtract two bytes from number of bytes to read
   \   000000C8   9702               SBIW    R25:R24, 2
    481          		} while (size); // Repeat until all block has been read
   \   000000CA   2F08               MOV     R16, R24
   \   000000CC   2B09               OR      R16, R25
   \   000000CE   F699               BRNE    ??BlockRead_3
    482          
    483          		(*address) >>= 1; // Convert address back to Flash words again.
   \   000000D0   910D               LD      R16, X+
   \   000000D2   911D               LD      R17, X+
   \   000000D4   912D               LD      R18, X+
   \   000000D6   913C               LD      R19, X
   \   000000D8   9713               SBIW    R27:R26, 3
   \   000000DA   9535               ASR     R19
   \   000000DC   9527               ROR     R18
   \   000000DE   9517               ROR     R17
   \   000000E0   9507               ROR     R16
   \   000000E2   930D               ST      X+, R16
   \   000000E4   931D               ST      X+, R17
   \   000000E6   932D               ST      X+, R18
   \   000000E8   933C               ST      X, R19
    484          	}
    485          }
   \                     ??BlockRead_2:
   \   000000EA   E0E5               LDI     R30, 5
   \   000000EC   ........           JMP     ?EPILOGUE_B5_L09
    486          #endif
    487          
    488          
    489          /* end of file */
    490          

   Maximum stack usage in bytes:

     Function             CSTACK RSTACK
     --------             ------ ------
     BlockLoad              267      3
       -> recchar           267      3
       -> recchar           267      3
       -> recchar           267      3
     BlockRead                5      3
       -> sendchar            5      3
       -> sendchar            5      3
       -> sendchar            5      3
     main                     4      3
       -> initbootuart        4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> BlockLoad           4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> recchar             4      3
       -> recchar             4      3
       -> BlockRead           4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> recchar             4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       -> sendchar            4      3
       ->   Indirect call     4      3


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     _A_SPMCSR         1
     _A_EEAR           2
     _A_EEDR           1
     _A_EECR           1
     _A_PORTD          1
     _A_PIND           1
     main           1020
     BlockLoad       394
     BlockRead       240

 
     7 bytes in segment ABSOLUTE
 1 654 bytes in segment FARCODE
 
 1 654 bytes of CODE memory
     0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
